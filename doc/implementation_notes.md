## Vector type specializations:

Due to implementation details in the clang C++ compiler, it is impossible to
declare templated typedefs of vector extension types. Moreover, the declaration
requires an integer literal for the `vector_size` attribute. Therefore we must
create a list of all the possible specializations for the underlying vector
types.

It should also be noted that we specialize for vector types which are
technically smaller and larger than "true" SIMD vector types for any particular
architecture. In particular, for each possible base type we provide vector types
with lane counts: 1, 2, 4, 8, 16, 32, 64. This is to allow general mappings over
SIMD vector types without fear that the resulting SIMD vector type does not have
a defined vector type specialization.

This is okay since both Clang and GCC will synthesize instructions that are not
present on the target architecture.

## Alignment concerns:

It should also be noted that we provide alignment values equal to the size of
each vector type. This is required to prevent penalties or exceptions for
unaligned memory accesses on architectures supporting only aligned accesses for
SIMD vector types. Often these alignment values will be larger than the value
`alignof (std::max_align_t)`, and so with GCC in particular warnings of
attribute alignment greater than `alignof (std::max_align_t)` will be emitted. I
have taken the liberty to insert `#pragma GCC diagnostic push/pop/ignored
"-Wattributes"` blocks around declarations using `alignas` to suppress these
warnings (these are the only place `#pragma` blocks are used). They are not
necessary and can be searched for and removed if desired.

## ABI concerns:

Each SIMD vector type (depending on underlying type and lane count), requires
backing either by a particular SIMD technology or synthesized instructions when
no appropriate SIMD technology is available on the target architecture. In the
case of the latter GCC may emit warnings about vector return types (in the
`-Wpsabi` category). It may also be useful to the user of this library to
explicitly enable the target SIMD technology they wish to use, this may be one
of, but is not limited to: `-mmmx`, `-msse`, `-msse2`, `-msse3`, `-mssse3`,
`-msse4`, `-msse4.{1,2}`, `-mavx`, `-mavx2`, `-mavx512{f,bw,cd,dq,er,ifma,pf,
vbmi,vl}`, `-mneon`.

## Vector comparisons generated by GCC vs. those generated by Clang:

GCC vector comparison operations return vector types with lane type equal to the
signed integer with size equal to the size of the original vector lane type.
However, the result type of vector comparisons generated by Clang are
`ext_vector_types` (OpenCL vector types). For that reason we must perform manual
conversion of comparisons when Clang is being used.

Additionally, GCC vector comparisons return lane values equal to `0` or `-1`
(strictly speaking a value of the appropriate lane type where all bits are set;
i.e. `2's` complement `-1`), representing false and true, respectively, while
Clang vector comparisons return lane values equal to `0` or `1`, representing
false and true, respectively. For reasons of consistency I have decided to
normalize the values to `0` and `1`, which means that the code compiled with
GCC involves a greedily evaluated integer mask operation for each construction
of a boolean SIMD type by an underlying SIMD vector (which are precisely those
constructions produced by comparison methods). For this reason values of `0` and
`1` represent false and true throughout this code, and should be used in client
code when explicitly constructing boolean SIMD types instead of `0` and `-1`,
regardless of compiler.

If it is necessary that `-1` be used as the truth value for compatibility
reasons, there is a class static function for boolean SIMD types named
`make_gcc_compatible` which saturates all bits in vector lanes with logical true
values while leaving all bits unset in vector lanes with logical false values.
Note, when compiling with Clang this method assumes the lane values are either
`0` or `1`. Incorrect behavior will occur if this precondition is broken.

## General discussion of comparison methods:

For all SIMD types we have overloads of `operator==`, and `operator!=`. For SIMD
types other than boolean types we also have overloads of `operator<`,
`operator>`, `operator<=`, and `operator>=`.

The same applies, of course, to floating point SIMD types. The overloads are
implemented in the naive way and, therefore, should probably not be used in
production code except when strict comparisons are actually desired. More
general and robust floating point comparisons can be easily implemented on top
of the primitive operations provided therein.

`namespace simd` implementations of `namespace std` mathematical functions: We
provide lane-by-lane overloads for the mathematical methods in the standard
headers `<cstdlib>` and `<cmath>`. Planned extensions include lane-by-lane
overloads in the `namespace simd` for those methods specified in the
Special Math TR, merged into the C++ standard as of C++17.

## Use of simd::shuffle ():
Clang's `__builtin_shufflevector` requires constant integer indices, and hence
we must implement the function by hand for the general case when this header is
compiled with Clang. For the user of this library this limitation can be
overcome by using the .data () method, which provides access to the underlying
SIMD vector type.

## We provide the following overloads for standard library methods:
- `operator<<` (narrow and wide character streams)
- `operator>>` (narrow and wide character streams)
- std::hash

It should be noted that std::hash computes a single value of type `std::size_t`,
while `simd::hash` computes hash values lane-by-lane.
