//
// simd; an implementation of SIMD vectors for C++ using GCC vector instrinsics
//
// author: Dalton Woodard
// contact: daltonmwoodard@gmail.com
// official repository: https://github.com/daltonwoodard/simd.git
// license:
//
// Copyright (c) 2016 DaltonWoodard. See the COPYRIGHT.md file at the top-level
// directory or at the listed source repository for details.
//
//      Licensed under the Apache License. Version 2.0:
//          https://www.apache.org/licenses/LICENSE-2.0
//      or the MIT License:
//          https://opensource.org/licenses/MIT
//      at the licensee's option. This file may not be copied, modified, or
//      distributed except according to those terms.
//

#ifndef SIMD_IMPLEMENTATION_HEADER
#define SIMD_IMPLEMENTATION_HEADER

#include <array>                // std::array
#include <cfloat>               // FLT_RADIX
#include <complex>              // std::complex
#include <cstddef>              // std::size_t
#include <cstdint>              // std::{u}int{8,16,32,64}_t
#include <cstring>              // std::memcpy
#include <functional>           // std::hash
#include <initializer_list>     // std::initializer_list
#include <iterator>             // std::iterator, std::reverse_iterator
#include <memory>               // std::align, std::addressof
#include <mutex>                // std::lock_guard, std::mutex
#include <new>                  // std::{get,set}_new_handler
#include <numeric>              // std::accumulate
#include <stdexcept>            // std::bad_alloc
#include <type_traits>          // std::conditional, std::is_arithmetic
#include <utility>              // std::forward, std::index_sequence
#include <iostream>

#if !defined (__clang__) && !defined (__GNUG__)
    #error "simd implemention requires clang or gcc vector extensions"
#endif

#if __cplusplus < 201103L
    #error "simd implementation requires C++11 support"
#endif

#if __cplusplus >= 201402L
    #define advanced_constexpr constexpr
#else
    #define advanced_constexpr
#endif

/* -- Implementation Notes --
 *
 * Vector type specializations:
 *      Due to implementation details in the clang C++ compiler, it is
 *      impossible to declare templated typedefs of vector extension types.
 *      Moreover, the declaration requires an integer literal for the
 *      vector_size attribute. Therefore we must create a list of all the
 *      possible specializations for the underlying vector types.
 *
 *      It should also be noted that we specialize for vector types which are
 *      technically smaller and larger than "true" SIMD vector types for any
 *      particular architecture. In particular, for each possible base type we
 *      provide vector types with lane counts: 1, 2, 4, 8, 16, 32, 64. This is
 *      to allow general mappings over SIMD vector types without fear that the
 *      resulting SIMD vector type does not have a defined vector type
 *      specialization.
 *
 *      This is okay since both Clang and GCC will synthesize instructions that
 *      are not present on the target architecure.
 *
 * Alignment concerns:
 *      It should also be noted that we provide alignment values equal to the
 *      size of each vector type. This is required to prevent penalties or
 *      exceptions for unaligned memory accesses on architectures supporting
 *      only aligned accesses for SIMD vector types. Often these alignment
 *      values will be larger than the value alignof (std::max_align_t), and so
 *      with GCC in particular warnings of attribute alignment greater than
 *      alignof (std::max_align_t) will be emitted. I have taken the liberty to
 *      insert #pragma GCC diagnostic push/pop/ignored "-Wattributes" blocks
 *      around declarations using alignas to supporess these warnings (these are
 *      the only place #pragma blocks are used). They are not necessary and can
 *      be searched for and removed if desired.
 *
 * ABI concerns:
 *      Each SIMD vector type (depending on underlying type and lane count),
 *      requires backing either by a particular SIMD technology or synthesized
 *      instructions when no appropriate SIMD technology is available on the
 *      target architecure. In the case of the latter GCC may emit warnings
 *      about vector return types (in the -Wpsabi catgeory). It may also be
 *      useful to the user of this library to explicitly enable the target SIMD
 *      technology they wish to use, this may be one of, but is not limited to:
 *      -mmmx, -msse, -msse2, -msse3, -mssse3, -msse4, -msse4.{1,2}, -mavx,
 *      -mavx2, -mavx512{f,bw,cd,dq,er,ifma,pf,vbmi,vl}, -mneon.
 *
 * Vector comparisons generated by GCC vs. those generated by Clang:
 *      GCC vector comparison operations return vector types with lane type
 *      equal to the signed integer with size equal to the size of the original
 *      vector lane type. However, the result type of vector comparisons
 *      generated by Clang are ext_vector_types (OpenCL vector types). For that
 *      reason we must perform manual conversion of comparisons when Clang is
 *      being used.
 *
 *      Additionally, GCC vector comparisons return lane values equal to 0 or
 *      -1 (strictly speaking a value of the appropriate lane type where all
 *      bits are set; i.e. 2's complement -1), representing false and true,
 *      respectively, while Clang vector comparisons return lane values equal to
 *      0 or 1, representing false and true, respectively. For reasons of
 *      consistency I have decided to normalize the values to 0 and 1, which
 *      means that the code compiled with GCC involves a greedily evaluated
 *      integer mask operation for each construction of a boolean SIMD type by
 *      an underlying SIMD vector (those constructions produced by comparison
 *      methods). For this reason values of 0 and 1 represent false and true
 *      throughout this code, and should be used in client code when explicitly
 *      constructing boolean SIMD types instead of 0 and -1, regardless of
 *      compiler.
 *
 *      If it is necessary that -1 be used as the truth value for compatibility
 *      reasons, there is a class static function for boolean SIMD types named
 *      `make_gcc_compatible` which saturates all bits in vector lanes with
 *      logical true values while leaving all bits unset in vetor lanes with
 *      logical false values. Note, when compiling with Clang this method
 *      assumes the lane values are either 0 or 1. Incorrect behavior will
 *      occur if this precondition is broken.
 *
 * General discussion of comparison methods:
 *      For all SIMD types we have overloads of operator==, and operator!=.
 *      For SIMD types other than boolean types we also have overloads of
 *      operator<, operator>, operator<=, and operator>=.
 *
 *      The same applies, of course, to floating point SIMD types. The overlaods
 *      are implemented in the naive way and, therefore, should probably not be
 *      used in production code except when strict comparisons are actually
 *      desired. More general and robust floating point comparisons can be
 *      easily implemented on top of the primitive operations provided herein.
 *
 * namespace simd implementations of namespace std mathematical functions:
 *      We provide lane-by-lane overloads for the mathematical methds in
 *      the standard headers <cstdlib> and <cmath>. Planned extensions include
 *      lane-by-lane overloads in the namespace simd for those methods specified
 *      in the Special Math TR, merged into the C++ standard as of C++17.
 *
 * Use of simd::shuffle ():
 *      Clang's __builtin_shufflevector requires constant integer indices,
 *      and hence we must implement the function by hand for the general
 *      case when this header is compiled with Clang. For the user of this
 *      library this limitation can be overcome by using the .data () method,
 *      which provides access to the underlying SIMD vector type.
 *
 * We provide the following overloads for standard library methods:
 *      - operator<< (narrow and wide character streams)
 *      - operator>> (narrow and wide character streams)
 *      - std::hash
 *
 *      It should be noted that std::hash computes a single value of type
 *      std::size_t, while simd::hash computes hash values lane-by-lane.
 */

namespace simd
{
namespace detail
{
namespace util
{
#if __cplusplus >= 201402L
    template <std::size_t ... v>
    using index_sequence = std::index_sequence <v...>;

    template <std::size_t N>
    using make_index_sequence = std::make_index_sequence <N>;
#else
    template <std::size_t ... v>
    struct index_sequence
    {
        using type = index_sequence;
        using value_type = std::size_t;

        static constexpr std::size_t size (void) noexcept
        {
            return sizeof... (v);
        }
    };

    template <typename, typename>
    struct merge;

    template <std::size_t ... v1, std::size_t ... v2>
    struct merge <index_sequence <v1...>, index_sequence <v2...>>
        : index_sequence <v1..., (sizeof... (v1) + v2)...>
    {};

    template <std::size_t N>
    struct seq_gen : merge <
        typename seq_gen <N/2>::type,
        typename seq_gen <N - N/2>::type
    >
    {};

    template <>
    struct seq_gen <0> : index_sequence <> {};

    template <>
    struct seq_gen <1> : index_sequence <0> {};

    template <std::size_t N>
    using make_index_sequence = typename seq_gen <N>::type;
#endif

    template <std::size_t L>
    struct lane_tag {};

    /*
     * Implemented for use in custom new implementation;
     * this method is threasafe, and consequently calls to new
     * on SIMD vector types are threadsafe as well (this becomes
     * a concern only in failing cases for memory allocation, which
     * typically will not occur on modern OSs that have overcommit
     * semantics).
     */
    void attempt_global_new_handler_call (void);
    void attempt_global_new_handler_call (void)
    {
        static std::mutex m;
        std::lock_guard <std::mutex> lock {m};

        auto global_new_handler = std::set_new_handler (nullptr);
        std::set_new_handler (global_new_handler);

        if (global_new_handler) {
            global_new_handler ();
        } else {
            throw std::bad_alloc {};
        }
    }

    /*
     * Allocates a block of memory of size bytes with alignment align.
     */
    void * aligned_allocate (std::size_t, std::size_t);
    void * aligned_allocate (std::size_t size, std::size_t alignment)
    {
#if __cplusplus > 201402L
        /* do we have C++17 support? */
        /* then use operator new with alignment spec */
        while (true) {
            auto const alloc_mem = ::operator new (size, alignment);
            if (alloc_mem) {
                return alloc_mem;
            } else {
                util::attempt_global_new_handler_call ();
            }
        }
#else
        /* then use our own implementation */
        while (true) {
            auto const alloc_sz  = size + alignment + sizeof (void *);
            auto const alloc_mem = ::operator new (alloc_sz);
            if (alloc_mem) {
                auto parg = static_cast <void *> (
                    reinterpret_cast <void **> (alloc_mem) + 1
                );
                auto sarg = size + alignment;
                auto const ptr = std::align (alignment, size, parg, sarg);
                reinterpret_cast <void **> (ptr) [-1] = alloc_mem;
                return ptr;
            } else {
                util::attempt_global_new_handler_call ();
            }
        }
#endif
    }

    /*
     * Deallocates a block of memory of size bytes with alignment align.
     */
    void aligned_deallocate (void *, std::size_t, std::size_t) noexcept;
    void aligned_deallocate (void * p, std::size_t size, std::size_t alignment)
        noexcept
    {
        if (!p) {
            return;
        }

#if __cplusplus > 201402L
        ::operator delete (p, size, alignment);
#else
        auto const alloc_size = size + alignment + sizeof (void *);
    #if __cplusplus >= 201402L
        ::operator delete (reinterpret_cast <void **> (p) [-1], alloc_size);
    #else
        (void) alloc_size;
        ::operator delete (reinterpret_cast <void **> (p) [-1]);
    #endif
#endif
    }

    /*
     * Hash combine for specialization of std::hash for SIMD vector types.
     */
    template <typename T>
    void hash_combine (std::size_t & seed, T const & t) noexcept
    {
        std::hash <T> hfn {};
        seed ^= hfn (t) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
    }

    /*
     * Non-modifying hash combine for specialization of std::hash for SIMD
     * vector types.
     */
    template <typename T>
    std::size_t hash_combine (std::size_t const & seed, T const & t)
        noexcept
    {
        std::hash <T> hfn {};
        auto sd = seed;
        sd ^= hfn (t) + 0x9e3779b9 + (sd << 6) + (sd >> 2);
        return sd;
    }

    /*
     * Hash combine for specialization of std::hash for SIMD vector types.
     */
    template <>
#if defined (__clang__)
    void hash_combine (std::size_t & seed, __int128_t const & t) noexcept
#elif defined (__GNUG__)
    void hash_combine (std::size_t & seed, __int128 const & t) noexcept
#endif
    {
        struct alias {
            std::int64_t a;
            std::int64_t b;
        };

        auto const & a = reinterpret_cast <alias const &> (t);
        std::hash <std::int64_t> hfn {};

        seed ^= hfn (a.a) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
        seed ^= hfn (a.b) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
    }

    /*
     * Non-modifying hash combine for specialization of std::hash for SIMD
     * vector types.
     */
    template <>
#if defined (__clang__)
    std::size_t hash_combine (std::size_t const & seed, __int128_t const & t)
        noexcept
#elif defined (__GNUG__)
    std::size_t hash_combine (std::size_t const & seed, __int128 const & t)
        noexcept
#endif
    {
        struct alias {
            std::int64_t a;
            std::int64_t b;
        };

        auto const & a = reinterpret_cast <alias const &> (t);
        std::hash <std::int64_t> hfn {};

        auto sd = seed;
        sd ^= hfn (a.a) + 0x9e3779b9 + (sd << 6) + (sd >> 2);
        sd ^= hfn (a.b) + 0x9e3779b9 + (sd << 6) + (sd >> 2);
        return sd;
    }

    /*
     * Hash combine for specialization of std::hash for SIMD vector types.
     */
    template <>
#if defined (__clang__)
    void hash_combine (std::size_t & seed, __uint128_t const & t) noexcept
#elif defined (__GNUG__)
    void hash_combine (std::size_t & seed, unsigned __int128 const & t) noexcept
#endif
    {
        struct alias {
            std::uint64_t a;
            std::uint64_t b;
        };

        auto const & a = reinterpret_cast <alias const &> (t);
        std::hash <std::uint64_t> hfn {};

        seed ^= hfn (a.a) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
        seed ^= hfn (a.b) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
    }

    /*
     * Non-modifying hash combine for specialization of std::hash for SIMD
     * vector types.
     */
    template <>
#if defined (__clang__)
    std::size_t hash_combine (std::size_t const & seed, __uint128_t const & t)
        noexcept
#elif defined (__GNUG__)
    std::size_t hash_combine (std::size_t const & seed,
                              unsigned __int128 const & t) noexcept
#endif
    {
        struct alias {
            std::uint64_t a;
            std::uint64_t b;
        };

        auto const & a = reinterpret_cast <alias const &> (t);
        std::hash <std::uint64_t> hfn {};

        auto sd = seed;
        sd ^= hfn (a.a) + 0x9e3779b9 + (sd << 6) + (sd >> 2);
        sd ^= hfn (a.b) + 0x9e3779b9 + (sd << 6) + (sd >> 2);
        return sd;
    }
}   // namespace util

namespace vext
{
    template <typename, std::size_t, typename enable = void>
    struct vector_type_specialization;

template <std::size_t lanes>
struct vector_type_specialization <signed char, lanes>
    : public vector_type_specialization <char, lanes>
{};

#define vsize(lanes, size) vector_size ((lanes) * (size))

#define specialize(ty, lanes) template <>\
struct vector_type_specialization <ty, lanes>\
{\
    typedef ty type __attribute__ ((vsize(lanes, sizeof (ty))));\
    static constexpr std::size_t alignment = lanes * alignof (ty);\
    static constexpr std::size_t size = lanes * sizeof (ty);\
};

    specialize(char, 1)
    specialize(char, 2)
    specialize(char, 4)
    specialize(char, 8)
    specialize(char, 16)
    specialize(char, 32)
    specialize(char, 64)

    specialize(unsigned char, 1)
    specialize(unsigned char, 2)
    specialize(unsigned char, 4)
    specialize(unsigned char, 8)
    specialize(unsigned char, 16)
    specialize(unsigned char, 32)
    specialize(unsigned char, 64)

    specialize(short, 1)
    specialize(short, 2)
    specialize(short, 4)
    specialize(short, 8)
    specialize(short, 16)
    specialize(short, 32)
    specialize(short, 64)

    specialize(unsigned short, 1)
    specialize(unsigned short, 2)
    specialize(unsigned short, 4)
    specialize(unsigned short, 8)
    specialize(unsigned short, 16)
    specialize(unsigned short, 32)
    specialize(unsigned short, 64)

    specialize(int, 1)
    specialize(int, 2)
    specialize(int, 4)
    specialize(int, 8)
    specialize(int, 16)
    specialize(int, 32)
    specialize(int, 64)

    specialize(unsigned int, 1)
    specialize(unsigned int, 2)
    specialize(unsigned int, 4)
    specialize(unsigned int, 8)
    specialize(unsigned int, 16)
    specialize(unsigned int, 32)
    specialize(unsigned int, 64)

    specialize(long, 1)
    specialize(long, 2)
    specialize(long, 4)
    specialize(long, 8)
    specialize(long, 16)
    specialize(long, 32)
    specialize(long, 64)

    specialize(unsigned long, 1)
    specialize(unsigned long, 2)
    specialize(unsigned long, 4)
    specialize(unsigned long, 8)
    specialize(unsigned long, 16)
    specialize(unsigned long, 32)
    specialize(unsigned long, 64)

    specialize(long long, 1)
    specialize(long long, 2)
    specialize(long long, 4)
    specialize(long long, 8)
    specialize(long long, 16)
    specialize(long long, 32)
    specialize(long long, 64)

    specialize(unsigned long long, 1)
    specialize(unsigned long long, 2)
    specialize(unsigned long long, 4)
    specialize(unsigned long long, 8)
    specialize(unsigned long long, 16)
    specialize(unsigned long long, 32)
    specialize(unsigned long long, 64)

    specialize(float, 1)
    specialize(float, 2)
    specialize(float, 4)
    specialize(float, 8)
    specialize(float, 16)
    specialize(float, 32)
    specialize(float, 64)

    specialize(double, 1)
    specialize(double, 2)
    specialize(double, 4)
    specialize(double, 8)
    specialize(double, 16)
    specialize(double, 32)
    specialize(double, 64)

    specialize(long double, 1)
    specialize(long double, 2)
    specialize(long double, 4)
    specialize(long double, 8)
    specialize(long double, 16)
    specialize(long double, 32)
    specialize(long double, 64)

#undef specialize

    template <>
    struct vector_type_specialization <
#if defined (__clang__)
        __int128_t,
#elif defined (__GNUG__)
        __int128,
#endif
        1
    >
    {
#if defined (__clang__)
        typedef __int128_t type
            __attribute__ ((vsize (1, sizeof (__int128_t))));
        static constexpr std::size_t alignment = 1 * alignof (__int128_t);
        static constexpr std::size_t size      = 1 * sizeof (__int128_t);
#elif defined (__GNUG__)
        typedef __int128 type __attribute__ ((vsize (1, sizeof (__int128))));
        static constexpr std::size_t alignment = 1 * alignof (__int128);
        static constexpr std::size_t size      = 1 * sizeof (__int128);
#endif
    };

    template <>
    struct vector_type_specialization <
#if defined (__clang__)
        __int128_t,
#elif defined (__GNUG__)
        __int128,
#endif
        2
    >
    {
#if defined (__clang__)
        typedef __int128_t type
            __attribute__ ((vsize (2, sizeof (__int128_t))));
        static constexpr std::size_t alignment = 2 * alignof (__int128_t);
        static constexpr std::size_t size      = 2 * sizeof (__int128_t);
#elif defined (__GNUG__)
        typedef __int128 type __attribute__ ((vsize (2, sizeof (__int128))));
        static constexpr std::size_t alignment = 2 * alignof (__int128);
        static constexpr std::size_t size      = 2 * sizeof (__int128);
#endif
    };

template <>
    struct vector_type_specialization <
#if defined (__clang__)
        __int128_t,
#elif defined (__GNUG__)
        __int128,
#endif
        4
    >
    {
#if defined (__clang__)
        typedef __int128_t type
            __attribute__ ((vsize (4, sizeof (__int128_t))));
        static constexpr std::size_t alignment = 4 * alignof (__int128_t);
        static constexpr std::size_t size      = 4 * sizeof (__int128_t);
#elif defined (__GNUG__)
        typedef __int128 type __attribute__ ((vsize (4, sizeof (__int128))));
        static constexpr std::size_t alignment = 4 * alignof (__int128);
        static constexpr std::size_t size      = 4 * sizeof (__int128);
#endif
    };

    template <>
    struct vector_type_specialization <
#if defined (__clang__)
        __int128_t,
#elif defined (__GNUG__)
        __int128,
#endif
        8
    >
    {
#if defined (__clang__)
        typedef __int128_t type
            __attribute__ ((vsize (8, sizeof (__int128_t))));
        static constexpr std::size_t alignment = 8 * alignof (__int128_t);
        static constexpr std::size_t size      = 8 * sizeof (__int128_t);
#elif defined (__GNUG__)
        typedef __int128 type __attribute__ ((vsize (8, sizeof (__int128))));
        static constexpr std::size_t alignment = 8 * alignof (__int128);
        static constexpr std::size_t size      = 8 * sizeof (__int128);
#endif
    };

    template <>
    struct vector_type_specialization <
#if defined (__clang__)
        __int128_t,
#elif defined (__GNUG__)
        __int128,
#endif
        16
    >
    {
#if defined (__clang__)
        typedef __int128_t type
            __attribute__ ((vsize (16, sizeof (__int128_t))));
        static constexpr std::size_t alignment = 16 * alignof (__int128_t);
        static constexpr std::size_t size      = 16 * sizeof (__int128_t);
#elif defined (__GNUG__)
        typedef __int128 type __attribute__ ((vsize (16, sizeof (__int128))));
        static constexpr std::size_t alignment = 16 * alignof (__int128);
        static constexpr std::size_t size      = 16 * sizeof (__int128);
#endif
    };

template <>
    struct vector_type_specialization <
#if defined (__clang__)
        __int128_t,
#elif defined (__GNUG__)
        __int128,
#endif
        32
    >
    {
#if defined (__clang__)
        typedef __int128_t type
            __attribute__ ((vsize (32, sizeof (__int128_t))));
        static constexpr std::size_t alignment = 32 * alignof (__int128_t);
        static constexpr std::size_t size      = 32 * sizeof (__int128_t);
#elif defined (__GNUG__)
        typedef __int128 type __attribute__ ((vsize (32, sizeof (__int128))));
        static constexpr std::size_t alignment = 32 * alignof (__int128);
        static constexpr std::size_t size      = 32 * sizeof (__int128);
#endif
    };

    template <>
    struct vector_type_specialization <
#if defined (__clang__)
        __int128_t,
#elif defined (__GNUG__)
        __int128,
#endif
        64
    >
    {
#if defined (__clang__)
        typedef __int128_t type
            __attribute__ ((vsize (64, sizeof (__int128_t))));
        static constexpr std::size_t alignment = 64 * alignof (__int128_t);
        static constexpr std::size_t size      = 64 * sizeof (__int128_t);
#elif defined (__GNUG__)
        typedef __int128 type __attribute__ ((vsize (64, sizeof (__int128))));
        static constexpr std::size_t alignment = 64 * alignof (__int128);
        static constexpr std::size_t size      = 64 * sizeof (__int128);
#endif
    };

    template <>
    struct vector_type_specialization <
#if defined (__clang__)
        __uint128_t,
#elif defined (__GNUG__)
        unsigned __int128,
#endif
        1
    >
    {
#if defined (__clang__)
        typedef __uint128_t type
            __attribute__ ((vsize (1, sizeof (__uint128_t))));
        static constexpr std::size_t alignment = 1 * alignof (__uint128_t);
        static constexpr std::size_t size      = 1 * sizeof (__uint128_t);
#elif defined (__GNUG__)
        typedef unsigned __int128 type
            __attribute__ ((vsize (1, sizeof (unsigned __int128))));
        static constexpr std::size_t alignment
            = 1 * alignof (unsigned __int128);
        static constexpr std::size_t size = 1 * sizeof (unsigned __int128);
#endif
    };

    template <>
    struct vector_type_specialization <
#if defined (__clang__)
        __uint128_t,
#elif defined (__GNUG__)
        unsigned __int128,
#endif
        2
    >
    {
#if defined (__clang__)
        typedef __uint128_t type
            __attribute__ ((vsize (2, sizeof (__uint128_t))));
        static constexpr std::size_t alignment = 2 * alignof (__uint128_t);
        static constexpr std::size_t size      = 2 * sizeof (__uint128_t);
#elif defined (__GNUG__)
        typedef unsigned __int128 type
            __attribute__ ((vsize (2, sizeof (unsigned __int128))));
        static constexpr std::size_t alignment
            = 2 * alignof (unsigned __int128);
        static constexpr std::size_t size = 2 * sizeof (unsigned __int128);
#endif
    };

template <>
    struct vector_type_specialization <
#if defined (__clang__)
        __uint128_t,
#elif defined (__GNUG__)
        unsigned __int128,
#endif
        4
    >
    {
#if defined (__clang__)
        typedef __uint128_t type
            __attribute__ ((vsize (4, sizeof (__uint128_t))));
        static constexpr std::size_t alignment = 4 * alignof (__uint128_t);
        static constexpr std::size_t size      = 4 * sizeof (__uint128_t);
#elif defined (__GNUG__)
        typedef unsigned __int128 type
            __attribute__ ((vsize (4, sizeof (unsigned __int128))));
        static constexpr std::size_t alignment
            = 4 * alignof (unsigned __int128);
        static constexpr std::size_t size = 4 * sizeof (unsigned __int128);
#endif
    };

    template <>
    struct vector_type_specialization <
#if defined (__clang__)
        __uint128_t,
#elif defined (__GNUG__)
        unsigned __int128,
#endif
        8
    >
    {
#if defined (__clang__)
        typedef __uint128_t type
            __attribute__ ((vsize (8, sizeof (__uint128_t))));
        static constexpr std::size_t alignment = 8 * alignof (__uint128_t);
        static constexpr std::size_t size      = 8 * sizeof (__uint128_t);
#elif defined (__GNUG__)
        typedef unsigned __int128 type
            __attribute__ ((vsize (8, sizeof (unsigned __int128))));
        static constexpr std::size_t alignment
            = 8 * alignof (unsigned __int128);
        static constexpr std::size_t size = 8 * sizeof (unsigned __int128);
#endif
    };

    template <>
    struct vector_type_specialization <
#if defined (__clang__)
        __uint128_t,
#elif defined (__GNUG__)
        unsigned __int128,
#endif
        16
    >
    {
#if defined (__clang__)
        typedef __uint128_t type
            __attribute__ ((vsize (16, sizeof (__uint128_t))));
        static constexpr std::size_t alignment = 16 * alignof (__uint128_t);
        static constexpr std::size_t size      = 16 * sizeof (__uint128_t);
#elif defined (__GNUG__)
        typedef unsigned __int128 type
            __attribute__ ((vsize (16, sizeof (unsigned __int128))));
        static constexpr std::size_t alignment
            = 16 * alignof (unsigned __int128);
        static constexpr std::size_t size = 16 * sizeof (unsigned __int128);
#endif
    };

template <>
    struct vector_type_specialization <
#if defined (__clang__)
        __uint128_t,
#elif defined (__GNUG__)
        unsigned __int128,
#endif
        32
    >
    {
#if defined (__clang__)
        typedef __uint128_t type
            __attribute__ ((vsize (32, sizeof (__uint128_t))));
        static constexpr std::size_t alignment
            = 32 * alignof (__uint128_t);
        static constexpr std::size_t size = 32 * sizeof (__uint128_t);
#elif defined (__GNUG__)
        typedef unsigned __int128 type
            __attribute__ ((vsize (32, sizeof (unsigned __int128))));
        static constexpr std::size_t alignment
            = 32 * alignof (unsigned __int128);
        static constexpr std::size_t size = 32 * sizeof (unsigned __int128);
#endif
    };

    template <>
    struct vector_type_specialization <
#if defined (__clang__)
         __uint128_t,
#elif defined (__GNUG__)
        unsigned __int128,
#endif
        64
    >
    {
#if defined (__clang__)
        typedef __uint128_t type
            __attribute__ ((vsize (64, sizeof (__uint128_t))));
        static constexpr std::size_t alignment = 64 * alignof (__uint128_t);
        static constexpr std::size_t size      = 64 * sizeof (__uint128_t);
#elif defined (__GNUG__)
        typedef unsigned __int128 type
            __attribute__ ((vsize (64, sizeof (unsigned __int128))));
        static constexpr std::size_t alignment
            = 64 * alignof (unsigned __int128);
        static constexpr std::size_t size = 64 * sizeof (unsigned __int128);
#endif
    };

#undef vsize

    template <typename T, std::size_t lanes>
    using vector = vector_type_specialization <T, lanes>;
}   // namespace vext

    template <typename T, std::size_t lanes>
    class simd_type_base;

    template <typename T, std::size_t lanes>
    class simd_type_base <std::complex <T>, lanes>
        : public simd_type_base <T, lanes>
    {};

    template <typename T>
    using integral_type_switch = typename std::conditional <
        sizeof (T) == 1,
        std::int8_t,
        typename std::conditional <
            sizeof (T) == 2,
            std::int16_t,
            typename std::conditional <
                sizeof (T) == 4,
                std::int32_t,
                typename std::conditional <
                    sizeof (T) == 8,
                    std::int64_t,
                    typename std::conditional <
                        sizeof (T) == 16 ||
                        sizeof (T) == 12 ||
                        sizeof (T) == 10,
#if defined (__clang__)
                        __int128_t,
#elif defined (__GNUG__)
                        __int128,
#endif
                        void
                    >::type
                >::type
            >::type
        >::type
    >::type;

    template <typename T>
    using unsigned_integral_type_switch = typename std::conditional <
        sizeof (T) == 1,
        std::uint8_t,
        typename std::conditional <
            sizeof (T) == 2,
            std::uint16_t,
            typename std::conditional <
                sizeof (T) == 4,
                std::uint32_t,
                typename std::conditional <
                    sizeof (T) == 8,
                    std::uint64_t,
                    typename std::conditional <
                        sizeof (T) == 16 ||
                        sizeof (T) == 12 ||
                        sizeof (T) == 10,
#if defined (__clang__)
                        __uint128_t,
#elif defined (__GNUG__)
                        unsigned __int128,
#endif
                        void
                    >::type
                >::type
            >::type
        >::type
    >::type;

    template <typename T, std::size_t lanes>
    class simd_type_base
    {
#if defined (__clang__)
        static_assert (
            std::is_arithmetic <T>::value ||
                std::is_same <T, __int128_t>::value ||
                std::is_same <T, __uint128_t>::value,
            "template parameter typename T must be an arithmetic type"
        );
#elif defined (__GNUG__)
        static_assert (
            std::is_arithmetic <T>::value ||
                std::is_same <T, __int128>::value ||
                std::is_same <T, unsigned __int128>::value,
            "template parameter typename T must be an arithmetic type"
        );
#endif

        static_assert (
            lanes > 0,
            "template parameter value lanes must be nonzero"
        );

        using base_value_type = T;

    public:
        using integral_type          = integral_type_switch <T>;
        using unsigned_integral_type = unsigned_integral_type_switch <T>;
        using signed_integral_type   = integral_type_switch <T>;

        static_assert (
            !std::is_same <integral_type, void>::value &&
                !std::is_same <unsigned_integral_type, void>::value,
            "template parameter typename T is too large"
        );

        static_assert (
            sizeof (integral_type) == sizeof (unsigned_integral_type) &&
            sizeof (integral_type) == sizeof (signed_integral_type),
            "error in selecting integral types: sizes do not compare equal"
        );

        using vector_type_impl = typename vext::vector <T, lanes>::type;

        static constexpr std::size_t alignment =
            vext::vector <T, lanes>::alignment;
        static constexpr std::size_t size = vext::vector <T, lanes>::size;

        simd_type_base (void) noexcept = default;
        simd_type_base (simd_type_base const &) noexcept = default;

        static void * operator new (std::size_t sz)
        {
            if (sz != size) {
                /* let standard new handle an incorrect size request */
                return ::operator new (sz);
            } else {
                return util::aligned_allocate (sz, alignment);
            }
        }

        static void * operator new [] (std::size_t sz)
        {
            return util::aligned_allocate (sz ? sz : size, alignment);
        }

/* overloads for C++17 operator new with alignement spec */
#if __cplusplus > 201402L
        static void * operator new (std::size_t sz, std::align_val_t al)
        {
            return ::operator new (sz, al)};
        }

        static void * operator new [] (std::size_t sz, std::align_val_t al)
        {
            return ::operator new [] (sz, al);
        }
#endif

#if __cplusplus >= 201402L
        static void operator delete (void * ptr, std::size_t sz) noexcept
#else
        static void operator delete (void * ptr) noexcept
#endif
        {
#if __cplusplus < 201402L
            std::size_t sz {size};
#endif
            if (ptr == nullptr) {
                return;
            } else if (sz != size) {
                /* let ::delete handle incorrectly sized delete requests */
#if __cplusplus >= 201402L
                ::operator delete (ptr, sz);
#else
                ::operator delete (ptr);
#endif
            } else {
                util::aligned_deallocate (ptr, sz, alignment);
            }
        }

#if __cplusplus >= 201402L
        static void operator delete [] (void * ptr, std::size_t sz) noexcept
#else
        static void operator delete [] (void * ptr) noexcept
#endif
        {
#if __cplusplus < 201402L
            std::size_t sz {size};
#endif
            if (ptr == nullptr) {
                return;
            } else if (!sz) {
                /* let ::delete handle incorrectly sized delete requests */
#if __cplusplus >= 201402L
                ::operator delete (ptr, sz);
#else
                ::operator delete (ptr);
#endif
            } else {
                util::aligned_deallocate (ptr, sz, alignment);
            }
        }

/* overloads for C++17 operator delete with alignment spec */
#if __cplusplus > 201402L
        static void
            operator delete (void * ptr, std::size_t sz, std::align_val_t al)
            noexcept
        {
            ::operator delete (ptr, sz, al);
        }

        static void
            operator delete [] (void * ptr, std::size_t sz, std::align_val_t al)
            noexcept
        {
            ::operator delete [] (ptr, sz, al);
        }
#endif
    private:
        template <std::size_t ... L>
        static constexpr
        vector_type_impl unpack_impl (base_value_type const (&arr) [lanes],
                                      util::index_sequence <L...>) noexcept
        {
            return vector_type_impl {arr [L]...};
        }

        template <std::size_t ... L>
        static constexpr
        vector_type_impl
            unpack_impl (std::array <base_value_type, lanes> const & arr,
                         util::index_sequence <L...>) noexcept
        {
            return vector_type_impl {arr [L]...};
        }

        template <typename U, std::size_t ... L>
        static constexpr vector_type_impl
            extend_impl (U const & u, util::index_sequence <L...>) noexcept
        {
            return vector_type_impl {((void) L, u)...};
        }

    protected:
        static constexpr vector_type_impl
            unpack (base_value_type const (&arr) [lanes]) noexcept
        {
            return simd_type_base::unpack_impl (
                arr, util::make_index_sequence <lanes> {}
            );
        }

        static constexpr vector_type_impl
            unpack (std::array <base_value_type, lanes> const & arr) noexcept
        {
            return simd_type_base::unpack_impl (
                arr, util::make_index_sequence <lanes> {}
            );
        }

        template <typename U>
        static constexpr vector_type_impl extend (U const & u) noexcept
        {
            return extend_impl (u, util::make_index_sequence <lanes> {});
        }

        template <
            typename ... Ts,
            typename = typename std::enable_if <
                sizeof... (Ts) == lanes && lanes != 1
            >::type
        >
        static constexpr vector_type_impl extend (Ts const & ... ts) noexcept
        {
            return vector_type_impl {static_cast <base_value_type> (ts)...};
        }

        template <typename vec_to, typename valtype, typename vec_from>
        static vec_to vector_convert (vec_from const & v, util::lane_tag <1>)
        {
            return vec_to {static_cast <valtype> (v [0])};
        }

        template <typename vec_to, typename valtype, typename vec_from>
        static vec_to vector_convert (vec_from const & v, util::lane_tag <2>)
        {
            return vec_to {
                static_cast <valtype> (v [0]), static_cast <valtype> (v [1])
            };
        }

        template <typename vec_to, typename valtype, typename vec_from>
        static vec_to vector_convert (vec_from const & v, util::lane_tag <4>)
        {
            return vec_to {
                static_cast <valtype> (v [0]), static_cast <valtype> (v [1]),
                static_cast <valtype> (v [2]), static_cast <valtype> (v [3])
            };
        }

        template <typename vec_to, typename valtype, typename vec_from>
        static vec_to vector_convert (vec_from const & v, util::lane_tag <8>)
        {
            return vec_to {
                static_cast <valtype> (v [0]), static_cast <valtype> (v [1]),
                static_cast <valtype> (v [2]), static_cast <valtype> (v [3]),
                static_cast <valtype> (v [4]), static_cast <valtype> (v [5]),
                static_cast <valtype> (v [6]), static_cast <valtype> (v [7])
            };
        }

        template <typename vec_to, typename valtype, typename vec_from>
        static vec_to vector_convert (vec_from const & v, util::lane_tag <16>)
        {
            return vec_to {
                static_cast <valtype> (v [0]),  static_cast <valtype> (v [1]),
                static_cast <valtype> (v [2]),  static_cast <valtype> (v [3]),
                static_cast <valtype> (v [4]),  static_cast <valtype> (v [5]),
                static_cast <valtype> (v [6]),  static_cast <valtype> (v [7]),
                static_cast <valtype> (v [8]),  static_cast <valtype> (v [9]),
                static_cast <valtype> (v [10]), static_cast <valtype> (v [11]),
                static_cast <valtype> (v [12]), static_cast <valtype> (v [13]),
                static_cast <valtype> (v [14]), static_cast <valtype> (v [15])
            };
        }

        template <typename vec_to, typename valtype, typename vec_from>
        static vec_to vector_convert (vec_from const & v, util::lane_tag <32>)
        {
            return vec_to {
                static_cast <valtype> (v [0]),  static_cast <valtype> (v [1]),
                static_cast <valtype> (v [2]),  static_cast <valtype> (v [3]),
                static_cast <valtype> (v [4]),  static_cast <valtype> (v [5]),
                static_cast <valtype> (v [6]),  static_cast <valtype> (v [7]),
                static_cast <valtype> (v [8]),  static_cast <valtype> (v [9]),
                static_cast <valtype> (v [10]), static_cast <valtype> (v [11]),
                static_cast <valtype> (v [12]), static_cast <valtype> (v [13]),
                static_cast <valtype> (v [14]), static_cast <valtype> (v [15]),
                static_cast <valtype> (v [16]), static_cast <valtype> (v [17]),
                static_cast <valtype> (v [18]), static_cast <valtype> (v [19]),
                static_cast <valtype> (v [20]), static_cast <valtype> (v [21]),
                static_cast <valtype> (v [22]), static_cast <valtype> (v [23]),
                static_cast <valtype> (v [24]), static_cast <valtype> (v [25]),
                static_cast <valtype> (v [26]), static_cast <valtype> (v [27]),
                static_cast <valtype> (v [28]), static_cast <valtype> (v [29]),
                static_cast <valtype> (v [30]), static_cast <valtype> (v [31])
            };
        }

        template <typename vec_to, typename valtype, typename vec_from>
        static vec_to vector_convert (vec_from const & v, util::lane_tag <64>)
        {
            return vec_to {
                static_cast <valtype> (v [0]),  static_cast <valtype> (v [1]),
                static_cast <valtype> (v [2]),  static_cast <valtype> (v [3]),
                static_cast <valtype> (v [4]),  static_cast <valtype> (v [5]),
                static_cast <valtype> (v [6]),  static_cast <valtype> (v [7]),
                static_cast <valtype> (v [8]),  static_cast <valtype> (v [9]),
                static_cast <valtype> (v [10]), static_cast <valtype> (v [11]),
                static_cast <valtype> (v [12]), static_cast <valtype> (v [13]),
                static_cast <valtype> (v [14]), static_cast <valtype> (v [15]),
                static_cast <valtype> (v [16]), static_cast <valtype> (v [17]),
                static_cast <valtype> (v [18]), static_cast <valtype> (v [19]),
                static_cast <valtype> (v [20]), static_cast <valtype> (v [21]),
                static_cast <valtype> (v [22]), static_cast <valtype> (v [23]),
                static_cast <valtype> (v [24]), static_cast <valtype> (v [25]),
                static_cast <valtype> (v [26]), static_cast <valtype> (v [27]),
                static_cast <valtype> (v [28]), static_cast <valtype> (v [29]),
                static_cast <valtype> (v [30]), static_cast <valtype> (v [31]),
                static_cast <valtype> (v [32]), static_cast <valtype> (v [33]),
                static_cast <valtype> (v [34]), static_cast <valtype> (v [35]),
                static_cast <valtype> (v [36]), static_cast <valtype> (v [37]),
                static_cast <valtype> (v [38]), static_cast <valtype> (v [39]),
                static_cast <valtype> (v [40]), static_cast <valtype> (v [41]),
                static_cast <valtype> (v [42]), static_cast <valtype> (v [43]),
                static_cast <valtype> (v [44]), static_cast <valtype> (v [45]),
                static_cast <valtype> (v [46]), static_cast <valtype> (v [47]),
                static_cast <valtype> (v [48]), static_cast <valtype> (v [49]),
                static_cast <valtype> (v [50]), static_cast <valtype> (v [51]),
                static_cast <valtype> (v [52]), static_cast <valtype> (v [53]),
                static_cast <valtype> (v [54]), static_cast <valtype> (v [55]),
                static_cast <valtype> (v [56]), static_cast <valtype> (v [57]),
                static_cast <valtype> (v [58]), static_cast <valtype> (v [59]),
                static_cast <valtype> (v [60]), static_cast <valtype> (v [61]),
                static_cast <valtype> (v [62]), static_cast <valtype> (v [63]),
            };
        }

        /*
         * This is a proxy reference object to avoid undefined behavior and
         * type-punning in derived SIMD type classes. It is the returned
         * type from methds such as operator[] and at().
         */
        template <typename VecType, typename ValType>
        class reference_proxy;

    public:
        using reference = reference_proxy <
            vector_type_impl, base_value_type
        >;
        using const_reference = reference_proxy <
            vector_type_impl const, base_value_type const
        >;

    protected:
        /*
         * This is a proxy pointer object to avoid undefined behavior and
         * type-punning in derived SIMD type classes. It is the returned
         * type from methds such as {c}{r}begin and {c}{r}end.
         */
        template <typename VecType, typename ValType>
        class pointer_proxy;

    public:
        using pointer = pointer_proxy <
            vector_type_impl, base_value_type
        >;
        using const_pointer = pointer_proxy <
            vector_type_impl const, base_value_type const
        >;

    protected:
        template <typename VecType, typename ValType>
        class reference_proxy
        {
        private:
            using vector_type = VecType;
            using value_type  = ValType;
            using pointer     = pointer_proxy <vector_type, value_type>;
            using vecpointer  = typename std::add_pointer <vector_type>::type;

            vecpointer _ref;
            std::ptrdiff_t _index;

        public:
            reference_proxy (void) = delete;
            ~reference_proxy (void) noexcept = default;

            constexpr reference_proxy (vecpointer p, std::ptrdiff_t index)
                noexcept
                : _ref   {p}
                , _index {index}
            {}

            constexpr
                reference_proxy (vector_type & v, std::ptrdiff_t index)
                noexcept
                : _ref   {&v}
                , _index {index}
            {}

            constexpr reference_proxy (reference_proxy const &) noexcept
                = default;

            template <typename U>
            reference_proxy & operator= (U && u) noexcept
            {
                static_assert (
                    std::is_convertible <U, value_type>::value,
                    "cannot assign to vector lane from non-convertible type"
                );

                (*this->_ref) [this->_index] = static_cast <value_type> (
                    std::forward <U> (u)
                );
                return *this;
            }

            reference_proxy & operator= (reference_proxy const & r) noexcept
            {
                this->_ref = r._ref;
                this->_index = r._index;
                return *this;
            }

            void swap (reference_proxy & r) noexcept
            {
                std::swap (this->_ref, r._ref);
                std::swap (this->_index, r._index);
            }

            template <typename U>
            constexpr operator U (void) const noexcept
            {
                static_assert (
                    std::is_convertible <value_type, U>::value,
                    "cannot perform cast"
                );

                return static_cast <U> ((*this->_ref) [this->_index]);
            }

            value_type data (void) const noexcept
            {
                return (*this->_ref) [this->_index];
            }

            pointer operator& (void) const noexcept
            {
                return pointer {this->_ref, this->_index};
            }

            constexpr bool operator== (reference_proxy const & r) const noexcept
            {
                return (*this->_ref) [this->_index] == (*r._ref) [r._index];
            }

            constexpr bool operator!= (reference_proxy const & r) const noexcept
            {
                return (*this->_ref) [this->_index] != (*r._ref) [r._index];
            }

            constexpr bool operator> (reference_proxy const & r) const noexcept
            {
                return (*this->_ref) [this->_index] > (*r._ref) [r._index];
            }

            constexpr bool operator< (reference_proxy const & r) const noexcept
            {
                return (*this->_ref) [this->_index] < (*r._ref) [r._index];
            }

            constexpr bool operator>= (reference_proxy const & r) const noexcept
            {
                return (*this->_ref) [this->_index] >= (*r._ref) [r._index];
            }

            constexpr bool operator<= (reference_proxy const & r) const noexcept
            {
                return (*this->_ref) [this->_index] <= (*r._ref) [r._index];
            }
        };

        template <typename VecType, typename ValType>
        class pointer_proxy
        {
        private:
            using vector_type = VecType;
            using value_type  = ValType;
            using vecpointer  = typename std::add_pointer <vector_type>::type;
            using reference   = reference_proxy <vector_type, value_type>;

            vecpointer _pointer;
            std::ptrdiff_t _index;

        public:
            using iterator_category = std::random_access_iterator_tag;

            constexpr pointer_proxy (void) noexcept
                : _pointer {nullptr}
                , _index   {0}
            {}

            ~pointer_proxy (void) noexcept = default;

            constexpr pointer_proxy (vecpointer p, std::ptrdiff_t index)
                noexcept
                : _pointer {p}
                , _index   {index}
            {}

            constexpr pointer_proxy (vector_type & v, std::ptrdiff_t index)
                noexcept
                : _pointer {&v}
                , _index   {index}
            {}

            constexpr pointer_proxy (pointer_proxy const &) noexcept = default;

            advanced_constexpr pointer_proxy & operator= (pointer_proxy p)
                noexcept
            {
                this->_pointer = p._pointer;
                this->_index = p._index;
                return *this;
            }

            operator vecpointer (void) noexcept
            {
                return this->_pointer;
            }

            operator bool (void) noexcept
            {
                return static_cast <bool> (this->_pointer);
            }

            reference operator* (void) const noexcept
            {
                return reference {this->_pointer, this->_index};
            }

            reference operator-> (void) const noexcept
            {
                return reference {this->_pointer, this->_index};
            }

            reference operator[] (std::ptrdiff_t n) const noexcept
            {
                return reference {this->_pointer, this->_index + n};
            }

            pointer_proxy & operator++ (void) noexcept
            {
                this->_index += 1;
                return *this;
            }

            pointer_proxy & operator-- (void) noexcept
            {
                this->_index -= 1;
                return *this;
            }

            pointer_proxy operator++ (int) noexcept
            {
                auto const tmp = *this;
                this->_index += 1;
                return tmp;
            }

            pointer_proxy operator-- (int) noexcept
            {
                auto const tmp = *this;
                this->_index -= 1;
                return tmp;
            }

            pointer_proxy & operator+= (std::ptrdiff_t n) noexcept
            {
                this->_index += n;
                return *this;
            }

            pointer_proxy & operator-= (std::ptrdiff_t n) noexcept
            {
                this->_index -= n;
                return *this;
            }

            pointer_proxy operator+ (std::ptrdiff_t n) const noexcept
            {
                auto tmp = *this;
                return tmp += n;
            }

            pointer_proxy operator- (std::ptrdiff_t n) const noexcept
            {
                auto tmp = *this;
                return tmp -= n;
            }

            std::ptrdiff_t operator- (pointer_proxy p) const noexcept
            {
                return this->_index - p._index;
            }

            bool operator== (pointer_proxy p) const noexcept
            {
                return this->_pointer == p._pointer &&
                       this->_index == p._index;
            }

            bool operator!= (pointer_proxy p) const noexcept
            {
                return this->_pointer != p._pointer ||
                       this->_index != p._index;
            }

            bool operator< (pointer_proxy p) const noexcept
            {
                return this->_pointer < p._pointer ||
                       (this->_pointer == p._pointer &&
                        this->_index < p._index);
            }

            bool operator> (pointer_proxy p) const noexcept
            {
                return this->_pointer > p._pointer ||
                       (this->_pointer == p._pointer &&
                        this->_index > p._index);
            }

            bool operator<= (pointer_proxy p) const noexcept
            {
                return this->_pointer < p._pointer ||
                       (this->_pointer == p._pointer &&
                        this->_index <= p._index);
            }

            bool operator>= (pointer_proxy p) const noexcept
            {
                return this->_pointer > p._pointer ||
                       (this->_pointer == p._pointer &&
                        this->_index >= p._index);
            }
        };
    };

    template <typename T, std::size_t lanes>
    class integral_simd_type;

    template <typename T, std::size_t lanes>
    class fp_simd_type;

    template <typename T, std::size_t lanes>
    class complex_simd_type;

    template <typename T, std::size_t lanes>
    class boolean_simd_type;

    struct arithmetic_tag;
    struct complex_tag;
    struct boolean_tag;

    template <typename T, std::size_t lanes, typename tag = arithmetic_tag>
    using simd_type = typename std::conditional <
        (std::is_integral <T>::value &&
            std::is_same <tag, arithmetic_tag>::value) ||
#if defined (__clang__)
        (std::is_same <T, __int128_t>::value &&
            std::is_same <tag, arithmetic_tag>::value)||
        (std::is_same <T, __uint128_t>::value &&
            std::is_same <tag, arithmetic_tag>::value),
#elif defined (__GNUG__)
        (std::is_same <T, __int128>::value &&
            std::is_same <tag, arithmetic_tag>::value)||
        (std::is_same <T, unsigned __int128>::value &&
            std::is_same <tag, arithmetic_tag>::value),
#endif
        integral_simd_type <T, lanes>,
        typename std::conditional <
            (std::is_integral <T>::value &&
                std::is_same <tag, boolean_tag>::value) ||
#if defined (__clang__)
            (std::is_same <T, __int128_t>::value &&
                std::is_same <tag, boolean_tag>::value) ||
            (std::is_same <T, __uint128_t>::value &&
                std::is_same <tag, boolean_tag>::value),
#elif defined (__GNUG__)
            (std::is_same <T, __int128>::value &&
                std::is_same <tag, boolean_tag>::value) ||
            (std::is_same <T, unsigned __int128>::value &&
                std::is_same <tag, boolean_tag>::value),
#endif
            boolean_simd_type <T, lanes>,
            typename std::conditional <
                std::is_floating_point <T>::value &&
                    std::is_same <tag, arithmetic_tag>::value,
                fp_simd_type <T, lanes>,
                typename std::conditional <
                    std::is_floating_point <T>::value &&
                        std::is_same <tag, complex_tag>::value,
                    complex_simd_type <T, lanes>,
                    void
                >::type
            >::type
        >::type
    >::type;

    template <typename>
    struct is_simd_type : std::false_type {};

    template <typename T, std::size_t lanes>
    struct is_simd_type <integral_simd_type <T, lanes>>
        : public std::true_type {};

    template <typename T, std::size_t lanes>
    struct is_simd_type <fp_simd_type <T, lanes>>
        : public std::true_type {};

    template <typename T, std::size_t lanes>
    struct is_simd_type <complex_simd_type <T, lanes>>
        : public std::true_type {};

    template <typename T, std::size_t lanes>
    struct is_simd_type <boolean_simd_type <T, lanes>>
        : public std::true_type {};

    template <typename T, std::size_t l, typename tag>
    struct simd_traits_base
    {
        using base                   = simd_type_base <T, l>;
        using vector_type            = typename base::vector_type_impl;
        using value_type             = T;
        using integral_type          = typename base::integral_type;
        using unsigned_integral_type = typename base::unsigned_integral_type;
        using signed_integral_type   = typename base::signed_integral_type;
        using reference              = typename base::reference;
        using const_reference        = typename base::const_reference;
        using iterator               = typename base::pointer;
        using const_iterator         = typename base::const_pointer;
        using reverse_iterator       = std::reverse_iterator <iterator>;
        using const_reverse_iterator = std::reverse_iterator <const_iterator>;
        using category_tag           = tag;

        static constexpr std::size_t alignment = base::alignment;
        static constexpr std::size_t size = base::size;
        static constexpr std::size_t lanes = l;
    };

    template <typename>
    struct simd_traits;

    template <typename T, std::size_t lanes>
    struct simd_traits <integral_simd_type <T, lanes>>
        : public simd_traits_base <T, lanes, arithmetic_tag>
    {};

    template <typename T, std::size_t lanes>
    struct simd_traits <fp_simd_type <T, lanes>>
        : public simd_traits_base <T, lanes, arithmetic_tag>
    {};

    template <typename T, std::size_t lanes>
    struct simd_traits <boolean_simd_type <T, lanes>>
        : public simd_traits_base <T, lanes, boolean_tag>
    {};

    template <typename T, std::size_t l>
    struct simd_traits <complex_simd_type <T, l>>
    {
        using base                   = simd_type_base <T, l>;
        using vector_type            = typename base::vector_type_impl;
        using value_type             = std::complex <T>;
        using integral_type          = typename base::integral_type;
        using unsigned_integral_type = typename base::unsigned_integral_type;
        using signed_integral_type   = typename base::signed_integral_type;
        using reference =
            typename complex_simd_type <T, l>::reference;
        using const_reference =
            typename complex_simd_type <T, l>::const_reference;
        using iterator =
            typename complex_simd_type <T, l>::iterator;
        using const_iterator =
            typename complex_simd_type <T, l>::const_iterator;
        using reverse_iterator =
            typename complex_simd_type <T, l>::reverse_iterator;
        using const_reverse_iterator =
            typename complex_simd_type <T, l>::const_reverse_iterator;
        using category_tag = complex_tag;

        static constexpr std::size_t alignment = base::alignment;
        static constexpr std::size_t size = base::size;
        static constexpr std::size_t lanes = l;
    };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wattributes"
    template <typename T, std::size_t l>
    class alignas (simd_type_base <T, l>::alignment)
        integral_simd_type : public simd_type_base <T, l>
    {
    private:
        using base = simd_type_base <T, l>;

        typename base::vector_type_impl _vec;

    public:
        static_assert (
            std::is_integral <T>::value ||
#if defined (__clang__)
            std::is_same <T, __int128_t>::value ||
            std::is_same <T, __uint128_t>::value,
#elif defined (__GNUG__)
            std::is_same <T, __int128>::value ||
            std::is_same <T, unsigned __int128>::value,
#endif
            "template parameter typename T must be an integral type"
        );

        using vector_type            = typename base::vector_type_impl;
        using value_type             = T;
        using integral_type          = typename base::integral_type;
        using unsigned_integral_type = typename base::unsigned_integral_type;
        using signed_integral_type   = typename base::signed_integral_type;
        using reference              = typename base::reference;
        using const_reference        = typename base::const_reference;
        using iterator               = typename base::pointer;
        using const_iterator         = typename base::const_pointer;
        using reverse_iterator       = std::reverse_iterator <iterator>;
        using const_reverse_iterator = std::reverse_iterator <const_iterator>;
        using category_tag           = arithmetic_tag;
        static constexpr std::size_t lanes = l;

        static_assert (
            sizeof (value_type) == sizeof (integral_type),
            "error in selecting integral type: size of value type does not"
            " compare equal"
        );

        template <typename U, std::size_t L, typename tag>
        using rebind = simd_type <U, L, tag>;

    private:
        template <std::size_t ... L>
        static constexpr integral_simd_type
            increment_vector_impl (integral_type from,
                                   util::index_sequence <L...>) noexcept
        {
            return integral_simd_type {
                (static_cast <integral_type> (L) + from)...
            };
        }

    public:
        static constexpr
        integral_simd_type increment_vector (value_type from = 0) noexcept
        {
            return increment_vector_impl (
                from, util::make_index_sequence <lanes> {}
            );
        }

        static integral_simd_type load (value_type const * addr) noexcept
        {
            integral_simd_type result;
            for (std::size_t i = 0; i < lanes; ++i) {
                result._vec [i] = *addr++;
            }
            return result;
        }

        static integral_simd_type load (value_type const * addr,
                                        std::ptrdiff_t off) noexcept
        {
            auto use_addr = addr + off;

            integral_simd_type result;
            for (std::size_t i = 0; i < lanes; ++i) {
                result._vec [i] = *use_addr++;
            }
            return result;
        }

        static integral_simd_type load (vector_type const * addr) noexcept
        {
            return integral_simd_type {*addr};
        }

        static integral_simd_type load (vector_type const * addr,
                                        std::ptrdiff_t off) noexcept
        {
            return integral_simd_type {*(addr + off)};
        }

        static integral_simd_type load_aligned (value_type const * addr)
            noexcept
        {
            auto aligned_ptr = static_cast <value_type const *> (
                __builtin_assume_aligned (addr, base::alignment)
            );

            integral_simd_type result;
            for (std::size_t i = 0; i < lanes; ++i) {
                result._vec [i] = *aligned_ptr++;
            }
            return result;
        }

        static integral_simd_type load_aligned (value_type const * addr,
                                                std::ptrdiff_t off) noexcept
        {
            auto use_addr = addr + off;
            auto aligned_ptr = static_cast <value_type const *> (
                __builtin_assume_aligned (use_addr, base::alignment)
            );

            integral_simd_type result;
            for (std::size_t i = 0; i < lanes; ++i) {
                result._vec [i] = *aligned_ptr++;
            }
            return result;
        }

        static integral_simd_type load_aligned (vector_type const * addr)
            noexcept
        {
            auto aligned_ptr = static_cast <vector_type const *> (
                __builtin_assume_aligned (addr, base::alignment)
            );

            return integral_simd_type {*aligned_ptr};
        }

        static integral_simd_type load_aligned (vector_type const * addr,
                                                std::ptrdiff_t off) noexcept
        {
            auto use_addr = addr + off;
            auto aligned_ptr = static_cast <vector_type const *> (
                __builtin_assume_aligned (use_addr, base::alignment)
            );

            return integral_simd_type {*aligned_ptr};
        }

        constexpr integral_simd_type (void) noexcept
            : _vec {base::extend (value_type {})}
        {}

        explicit constexpr integral_simd_type (vector_type const & vec) noexcept
            : _vec {vec}
        {}

        explicit constexpr integral_simd_type (value_type const & val) noexcept
            : _vec {base::extend (val)}
        {}

        template <
            typename ... value_types,
            typename = typename std::enable_if <
                sizeof... (value_types) == lanes && lanes != 1
            >::type
        >
        explicit constexpr integral_simd_type (value_types && ... vals) noexcept
            : _vec {
                static_cast <value_type> (std::forward <value_types> (vals))...
            }
        {}

        constexpr
        integral_simd_type (integral_simd_type const & sv) noexcept
            : base {}
            , _vec {sv._vec}
        {}

        explicit constexpr
        integral_simd_type (value_type const (&arr) [lanes]) noexcept
            : _vec {base::unpack (arr)}
        {}

        explicit constexpr
        integral_simd_type (std::array <value_type, lanes> const & arr) noexcept
            : _vec {base::unpack (arr)}
        {}

        advanced_constexpr
        integral_simd_type & operator= (integral_simd_type const & sv) &
            noexcept
        {
            this->_vec = sv._vec;
            return *this;
        }

        template <typename U>
        advanced_constexpr integral_simd_type & operator= (U val) & noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            this->_vec = base::extend (val);
            return *this;
        }

    private:
        template <std::size_t ... L>
        advanced_constexpr void
            fill_array (std::array <value_type, lanes> & arr,
                        util::index_sequence <L...>) const noexcept
        {
            value_type _unused [] = {
                (std::get <L> (arr) = this->template get <L> ())...
            };
            (void) _unused;
        }

    public:
        explicit advanced_constexpr
            operator std::array <value_type, lanes> (void) const noexcept
        {
            std::array <value_type, lanes> result {};
            this->fill_array (result, util::make_index_sequence <lanes> {});
            return result;
        }

    private:
        template <typename vec_from, typename valtype>
        static vec_from vector_convert (vec_from const & v) noexcept
        {
            return v;
        }

        template <typename vec_to, typename valtype, typename vec_from>
        static vec_to vector_convert (vec_from const & v) noexcept
        {
#if defined (__clang__)
            return static_cast <vec_to> (v);
#elif defined (__GNUG__)
            return base::template vector_convert <vec_to, valtype> (
                v, util::lane_tag <lanes> {}
            );
#endif
        }

    public:
        template <typename SimdT>
        constexpr SimdT to (void) const noexcept
        {
            static_assert (
                is_simd_type <SimdT>::value,
                "cannot perform cast to non-simd type"
            );

            using cast_traits = simd_traits <SimdT>;
            using rebind_type = rebind <
                typename cast_traits::value_type,
                cast_traits::lanes,
                typename cast_traits::category_tag
            >;
            using rebind_vector_type = typename rebind_type::vector_type;
            using rebind_value_type = typename rebind_type::value_type;

            static_assert (
                lanes == cast_traits::lanes,
                "cannot perform conversion of vector type to vector type with a"
                " different number of lanes"
            );

            return rebind_type {
                vector_convert <rebind_vector_type, rebind_value_type> (
                    this->_vec
                )
            };
        }

        template <typename SimdT>
        constexpr operator SimdT (void) const noexcept
        {
            return this->template to <SimdT> ();
        }

        template <typename SimdT>
        SimdT as (void) const noexcept
        {
            static_assert (
                is_simd_type <SimdT>::value,
                "cannot perform cast to non-simd type"
            );

            using cast_traits = simd_traits <SimdT>;
            using rebind_type = rebind <
                typename cast_traits::value_type,
                cast_traits::lanes,
                typename cast_traits::category_tag
            >;
            using rebind_vector_type = typename rebind_type::vector_type;

            static_assert (
                sizeof (vector_type) == sizeof (rebind_vector_type),
                "cannot reinterpret vector to differently sized vector type"
            );

            return rebind_type {
                reinterpret_cast <rebind_vector_type> (this->_vec)
            };
        }

        advanced_constexpr void swap (integral_simd_type & other) noexcept
        {
            auto tmp = *this;
            *this = other;
            other = tmp;
        }

        advanced_constexpr vector_type & data (void) & noexcept
        {
            return this->_vec;
        }

        constexpr vector_type const & data (void) const & noexcept
        {
            return this->_vec;
        }

        constexpr value_type value (std::size_t n) const noexcept
        {
            return this->_vec [n];
        }

        advanced_constexpr void fill (value_type const & val) & noexcept
        {
            this->_vec = base::extend (val);
        }

        advanced_constexpr void
            assign (std::size_t n, value_type const & val) & noexcept
        {
            this->_vec [n] = val;
        }

        advanced_constexpr void
            assign (std::initializer_list <value_type> & vl) & noexcept
        {
            auto vals = vl.begin ();
            std::size_t i = 0;
            for (; i < std::min (lanes, vl.size ()); ++i) {
                this->_vec [i] = vals [i];
            }
            for (; i < lanes; ++i) {
                this->_vec [i] = value_type {0};
            }
        }

        template <std::size_t n>
        constexpr const_reference get (void) const & noexcept
        {
            static_assert (
                n < lanes,
                "cannot access out-of-bounds vector lane"
            );

            return const_reference {
                &this->_vec, static_cast <std::ptrdiff_t> (n)
            };
        }

        template <std::size_t n>
        advanced_constexpr reference get (void) & noexcept
        {
            static_assert (
                n < lanes,
                "cannot access out-of-bounds vector lane"
            );

            return reference {&this->_vec, static_cast <std::ptrdiff_t> (n)};
        }

        template <std::size_t n>
        advanced_constexpr integral_simd_type & set (value_type const & val) &
            noexcept
        {
            static_assert (
                n < lanes,
                "cannot access out-of-bounds vector lane"
            );

            this->_vec [n] = val;
            return *this;
        }

        constexpr const_reference operator[] (std::size_t n) const & noexcept
        {
            return const_reference {
                &this->_vec, static_cast <std::ptrdiff_t> (n)
            };
        }

        advanced_constexpr reference operator[] (std::size_t n) & noexcept
        {
            return reference {
                &this->_vec, static_cast <std::ptrdiff_t> (n)
            };
        }

        constexpr const_reference at (std::size_t n) const &
        {
            return n < lanes ?
                const_reference {this->_vec, n} :
                throw std::out_of_range {
                    "access attempt to out-of-bounds vector lane"
                };
        }

        advanced_constexpr reference at (std::size_t n) &
        {
            return n < lanes ?
                reference {this->_vec, n} :
                throw std::out_of_range {
                    "access attempt to out-of-bounds vector lane"
                };
        }

        advanced_constexpr iterator begin (void) & noexcept
        {
            return iterator {this->data (), 0};
        }

        advanced_constexpr iterator end (void) & noexcept
        {
            return iterator {
                this->data (), static_cast <std::ptrdiff_t> (lanes)
            };
        }

        constexpr const_iterator begin (void) const & noexcept
        {
            return const_iterator {this->data (), 0};
        }

        constexpr const_iterator end (void) const & noexcept
        {
            return const_iterator {
                this->data (), static_cast <std::ptrdiff_t> (lanes)
            };
        }

        constexpr const_iterator cbegin (void) const & noexcept
        {
            return const_iterator {this->data (), 0};
        }

        constexpr const_iterator cend (void) const & noexcept
        {
            return const_iterator {
                this->data (), static_cast <std::ptrdiff_t> (lanes)
            };
        }

        advanced_constexpr reverse_iterator rbegin (void) & noexcept
        {
            return reverse_iterator {
                this->data (), static_cast <std::ptrdiff_t> (lanes)
            };
        }

        advanced_constexpr reverse_iterator rend (void) & noexcept
        {
            return reverse_iterator {this->data (), 0};
        }

        constexpr const_reverse_iterator rbegin (void) const & noexcept
        {
            return const_reverse_iterator {
                this->data (), static_cast <std::ptrdiff_t> (lanes)
            };
        }

        constexpr const_reverse_iterator rend (void) const & noexcept
        {
            return const_reverse_iterator {this->data (), 0};
        }

        constexpr const_reverse_iterator crbegin (void) const & noexcept
        {
            return const_reverse_iterator {
                this->data (), static_cast <std::ptrdiff_t> (lanes)
            };
        }

        constexpr const_reverse_iterator crend (void) const & noexcept
        {
            return const_reverse_iterator {this->data (), 0};
        }

        constexpr integral_simd_type operator+ (void) const noexcept
        {
            return integral_simd_type {+this->_vec};
        }

        constexpr integral_simd_type operator- (void) const noexcept
        {
            return integral_simd_type {-this->_vec};
        }

        advanced_constexpr integral_simd_type & operator++ (void) noexcept
        {
            this->operator+ (1);
            return *this;
        }

        advanced_constexpr integral_simd_type & operator-- (void) noexcept
        {
            this->operator- (1);
            return *this;
        }

        advanced_constexpr integral_simd_type operator++ (int) noexcept
        {
            auto const tmp = *this;
            this->operator+ (1);
            return tmp;
        }

        advanced_constexpr integral_simd_type operator-- (int) noexcept
        {
            auto const tmp = *this;
            this->operator- (1);
            return tmp;
        }

        constexpr
        integral_simd_type operator+ (integral_simd_type const & sv) const
            noexcept
        {
            return integral_simd_type {this->_vec + sv._vec};
        }

        template <typename U>
        constexpr integral_simd_type operator+ (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return integral_simd_type {this->_vec + base::extend (val)};
        }

        constexpr integral_simd_type operator- (integral_simd_type const & sv)
            const noexcept
        {
            return integral_simd_type {this->_vec - sv._vec};
        }

        template <typename U>
        constexpr integral_simd_type operator- (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return integral_simd_type {this->_vec - base::extend (val)};
        }

        constexpr integral_simd_type operator* (integral_simd_type const & sv)
            const noexcept
        {
            return integral_simd_type {this->_vec * sv._vec};
        }

        template <typename U>
        constexpr integral_simd_type operator* (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return integral_simd_type {this->_vec * base::extend (val)};
        }

        constexpr integral_simd_type operator/ (integral_simd_type const & sv)
            const noexcept
        {
            return integral_simd_type {this->_vec / sv._vec};
        }

        template <typename U>
        constexpr integral_simd_type operator/ (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return integral_simd_type {this->_vec / base::extend (val)};
        }

        constexpr integral_simd_type operator% (integral_simd_type const & sv)
            const noexcept
        {
            return integral_simd_type {this->_vec % sv._vec};
        }

        template <typename U>
        constexpr integral_simd_type operator% (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return integral_simd_type {this->_vec % base::extend (val)};
        }

        constexpr integral_simd_type operator~ (void) const noexcept
        {
            return integral_simd_type {~this->_vec};
        }

        constexpr integral_simd_type operator& (integral_simd_type const & sv)
            const noexcept
        {
            return integral_simd_type {this->_vec & sv._vec};
        }

        template <typename U>
        constexpr integral_simd_type operator& (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return integral_simd_type {this->_vec & base::extend (val)};
        }

        constexpr integral_simd_type operator| (integral_simd_type const & sv)
            const noexcept
        {
            return integral_simd_type {this->_vec | sv._vec};
        }

        template <typename U>
        constexpr integral_simd_type operator| (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return integral_simd_type {this->_vec | base::extend (val)};
        }

        constexpr integral_simd_type operator^ (integral_simd_type const & sv)
            const noexcept
        {
            return integral_simd_type {this->_vec ^ sv._vec};
        }

        template <typename U>
        constexpr integral_simd_type operator^ (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return integral_simd_type {this->_vec ^ base::extend (val)};
        }

        constexpr integral_simd_type operator! (void) const noexcept
        {
            return integral_simd_type {!this->_vec};
        }

        constexpr integral_simd_type operator&& (integral_simd_type const & sv)
            const noexcept
        {
            return integral_simd_type {this->_vec && sv._vec};
        }

        template <typename U>
        constexpr integral_simd_type operator&& (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return integral_simd_type {this->_vec && base::extend (val)};
        }

        constexpr integral_simd_type operator|| (integral_simd_type const & sv)
            const noexcept
        {
            return integral_simd_type {this->_vec || sv._vec};
        }

        template <typename U>
        constexpr integral_simd_type operator|| (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return integral_simd_type {this->_vec || base::extend (val)};
        }

        constexpr integral_simd_type operator<< (integral_simd_type const & sv)
            const noexcept
        {
            return integral_simd_type {this->_vec << sv._vec};
        }

        constexpr integral_simd_type operator<< (value_type shl_val)
            const noexcept
        {
            return *this << integral_simd_type {shl_val};
        }

        constexpr integral_simd_type operator>> (integral_simd_type const & sv)
            const noexcept
        {
            return integral_simd_type {this->_vec >> sv._vec};
        }

        constexpr integral_simd_type operator>> (value_type shl_val)
            const noexcept
        {
            return *this >> integral_simd_type {shl_val};
        }

        advanced_constexpr
        integral_simd_type & operator+= (integral_simd_type const & sv) &
            noexcept
        {
            this->_vec += sv._vec;
            return *this;
        }

        template <typename U>
        advanced_constexpr integral_simd_type & operator+= (U val) & noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            this->_vec += base::extend (val);
            return *this;
        }

        advanced_constexpr
        integral_simd_type & operator-= (integral_simd_type const & sv) &
            noexcept
        {
            this->_vec -= sv._vec;
            return *this;
        }

        template <typename U>
        advanced_constexpr integral_simd_type & operator-= (U val) & noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            this->_vec -= base::extend (val);
            return *this;
        }

        advanced_constexpr
        integral_simd_type & operator*= (integral_simd_type const & sv) &
            noexcept
        {
            this->_vec *= sv._vec;
            return *this;
        }

        template <typename U>
        advanced_constexpr integral_simd_type & operator*= (U val) & noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            this->_vec *= base::extend (val);
            return *this;
        }

        advanced_constexpr
        integral_simd_type & operator/= (integral_simd_type const & sv) &
            noexcept
        {
            this->_vec /= sv._vec;
            return *this;
        }

        template <typename U>
        advanced_constexpr integral_simd_type & operator/= (U val) & noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            this->_vec /= base::extend (val);
            return *this;
        }

        advanced_constexpr
        integral_simd_type & operator%= (integral_simd_type const & sv) &
            noexcept
        {
            this->_vec %= sv._vec;
            return *this;
        }

        template <typename U>
        advanced_constexpr integral_simd_type & operator%= (U val) & noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            this->_vec %= base::extend (val);
            return *this;
        }

        advanced_constexpr
        integral_simd_type & operator&= (integral_simd_type const & sv) &
            noexcept
        {
            this->_vec &= sv._vec;
            return *this;
        }

        template <typename U>
        advanced_constexpr integral_simd_type & operator&= (U val) & noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            this->_vec &= base::extend (val);
            return *this;
        }

        advanced_constexpr
        integral_simd_type & operator|= (integral_simd_type const & sv) &
            noexcept
        {
            this->_vec |= sv._vec;
            return *this;
        }

        template <typename U>
        advanced_constexpr integral_simd_type & operator|= (U val) & noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            this->_vec |= base::extend (val);
            return *this;
        }

        advanced_constexpr
        integral_simd_type & operator^= (integral_simd_type const & sv) &
            noexcept
        {
            this->_vec ^= sv._vec;
            return *this;
        }

        template <typename U>
        advanced_constexpr integral_simd_type & operator^= (U val) & noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            this->_vec ^= base::extend (val);
            return *this;
        }

        advanced_constexpr
        integral_simd_type & operator<<= (integral_simd_type const & sv) &
            noexcept
        {
            this->_vec <<= sv._vec;
            return *this;
        }

        template <typename U>
        advanced_constexpr integral_simd_type & operator<<= (U val) & noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            this->_vec <<= base::extend (val);
            return *this;
        }

        advanced_constexpr
        integral_simd_type & operator>>= (integral_simd_type const & sv) &
            noexcept
        {
            this->_vec >>= sv._vec;
            return *this;
        }

        template <typename U>
        advanced_constexpr integral_simd_type & operator>>= (U val) & noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            this->_vec >>= base::extend (val);
            return *this;
        }

#if defined (__clang__)
    private:
        template <typename Comparison, std::size_t ... L>
        static constexpr boolean_simd_type <integral_type, lanes>
            unpack_comparison (Comparison && c, util::index_sequence <L...>)
            noexcept
        {
            return boolean_simd_type <integral_type, lanes> {
                std::forward <Comparison> (c) [L]...
            };
        }

    public:
#endif
        constexpr boolean_simd_type <integral_type, lanes>
            operator== (integral_simd_type const & sv) const noexcept
        {
#if defined (__clang__)
            return unpack_comparison (
                this->_vec == sv._vec, util::make_index_sequence <lanes> {}
            );
#elif defined (__GNUG__)
            return boolean_simd_type <integral_type, lanes> {
                this->_vec == sv._vec
            };
#endif
        }

        template <typename U>
        constexpr boolean_simd_type <integral_type, lanes> operator== (U val)
            const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return *this == integral_simd_type {val};
        }

        constexpr boolean_simd_type <integral_type, lanes>
            operator!= (integral_simd_type const & sv) const noexcept
        {
#if defined (__clang__)
            return unpack_comparison (
                this->_vec != sv._vec, util::make_index_sequence <lanes> {}
            );
#elif defined (__GNUG__)
            return boolean_simd_type <integral_type, lanes> {
                this->_vec != sv._vec
            };
#endif
        }

        template <typename U>
        constexpr boolean_simd_type <integral_type, lanes>
            operator!= (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return *this != integral_simd_type {val};
        }

        constexpr boolean_simd_type <integral_type, lanes>
            operator> (integral_simd_type const & sv) const noexcept
        {
#if defined (__clang__)
            return unpack_comparison (
                this->_vec > sv._vec, util::make_index_sequence <lanes> {}
            );
#elif defined (__GNUG__)
            return boolean_simd_type <integral_type, lanes> {
                this->_vec > sv._vec
            };
#endif
        }

        template <typename U>
        constexpr boolean_simd_type <integral_type, lanes>
            operator> (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return *this > integral_simd_type {val};
        }

        constexpr boolean_simd_type <integral_type, lanes>
            operator< (integral_simd_type const & sv) const noexcept
        {
#if defined (__clang__)
            return unpack_comparison (
                this->_vec < sv._vec, util::make_index_sequence <lanes> {}
            );
#elif defined (__GNUG__)
            return boolean_simd_type <integral_type, lanes> {
                this->_vec < sv._vec
            };
#endif
        }

        template <typename U>
        constexpr boolean_simd_type <integral_type, lanes>
            operator< (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return *this < integral_simd_type {val};
        }

        constexpr boolean_simd_type <integral_type, lanes>
            operator>= (integral_simd_type const & sv) const noexcept
        {
#if defined (__clang__)
            return unpack_comparison (
                this->_vec >= sv._vec, util::make_index_sequence <lanes> {}
            );
#elif defined (__GNUG__)
            return boolean_simd_type <integral_type, lanes> {
                this->_vec >= sv._vec
            };
#endif
        }

        template <typename U>
        constexpr boolean_simd_type <integral_type, lanes>
            operator>= (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return *this >= integral_simd_type {val};
        }

        constexpr boolean_simd_type <integral_type, lanes>
            operator<= (integral_simd_type const & sv) const noexcept
        {
#if defined (__clang__)
            return unpack_comparison (
                this->_vec <= sv._vec, util::make_index_sequence <lanes> {}
            );
#elif defined (__GNUG__)
            return boolean_simd_type <integral_type, lanes> {
                this->_vec <= sv._vec
            };
#endif
        }

        template <typename U>
        constexpr boolean_simd_type <integral_type, lanes>
            operator<= (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return *this <= integral_simd_type {val};
        }
    };
#pragma GCC diagnostic pop

    template <typename T, std::size_t lanes>
    class fp_simd_type;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wattributes"
    template <typename T, std::size_t l>
    class alignas (simd_type_base <T, l>::alignment)
        fp_simd_type : public simd_type_base <T, l>
    {
    private:
        using base = simd_type_base <T, l>;

        typename base::vector_type_impl _vec;

    public:
        static_assert (
            std::is_floating_point <T>::value,
            "template parameter typename T must be a floating point type"
        );

        using vector_type            = typename base::vector_type_impl;
        using value_type             = T;
        using integral_type          = typename base::integral_type;
        using unsigned_integral_type = typename base::unsigned_integral_type;
        using signed_integral_type   = typename base::signed_integral_type;
        using reference              = typename base::reference;
        using const_reference        = typename base::const_reference;
        using iterator               = typename base::pointer;
        using const_iterator         = typename base::const_pointer;
        using reverse_iterator       = std::reverse_iterator <iterator>;
        using const_reverse_iterator = std::reverse_iterator <const_iterator>;
        using category_tag           = arithmetic_tag;
        static constexpr std::size_t lanes = l;

        template <typename U, std::size_t L, typename tag>
        using rebind = simd_type <U, L, tag>;

        static fp_simd_type load (value_type const * addr) noexcept
        {
            fp_simd_type result;
            for (std::size_t i = 0; i < lanes; ++i) {
                result._vec [i] = *addr++;
            }
            return result;
        }

        static fp_simd_type load (value_type const * addr,
                                  std::ptrdiff_t off) noexcept
        {
            auto use_addr = addr + off;

            fp_simd_type result;
            for (std::size_t i = 0; i < lanes; ++i) {
                result._vec [i] = *use_addr++;
            }
            return result;
        }

        static fp_simd_type load (vector_type const * addr) noexcept
        {
            return fp_simd_type {*addr};
        }

        static fp_simd_type load (vector_type const * addr,
                                  std::ptrdiff_t off) noexcept
        {
            return fp_simd_type {*(addr + off)};
        }

        static fp_simd_type load_aligned (value_type const * addr)
            noexcept
        {
            auto aligned_ptr = static_cast <value_type const *> (
                __builtin_assume_aligned (addr, base::alignment)
            );

            fp_simd_type result;
            for (std::size_t i = 0; i < lanes; ++i) {
                result._vec [i] = *aligned_ptr++;
            }
            return result;
        }

        static fp_simd_type load_aligned (value_type const * addr,
                                          std::ptrdiff_t off) noexcept
        {
            auto use_addr = addr + off;
            auto aligned_ptr = static_cast <value_type const *> (
                __builtin_assume_aligned (use_addr, base::alignment)
            );

            fp_simd_type result;
            for (std::size_t i = 0; i < lanes; ++i) {
                result._vec [i] = *aligned_ptr++;
            }
            return result;
        }

        static fp_simd_type load_aligned (vector_type const * addr)
            noexcept
        {
            auto aligned_ptr = static_cast <vector_type const *> (
                __builtin_assume_aligned (addr, base::alignment)
            );

            return fp_simd_type {*aligned_ptr};
        }

        static fp_simd_type load_aligned (vector_type const * addr,
                                          std::ptrdiff_t off) noexcept
        {
            auto use_addr = addr + off;
            auto aligned_ptr = static_cast <vector_type const *> (
                __builtin_assume_aligned (use_addr, base::alignment)
            );

            return fp_simd_type {*aligned_ptr};
        }

        constexpr fp_simd_type (void) noexcept
            : _vec {base::extend (value_type {})}
        {}

        explicit constexpr fp_simd_type (vector_type const & vec) noexcept
            : _vec {vec}
        {}

        explicit constexpr fp_simd_type (value_type const & val) noexcept
            : _vec {base::extend (val)}
        {}

        template <
            typename ... value_types,
            typename = typename std::enable_if <
                sizeof... (value_types) == lanes && lanes != 1
            >::type
        >
        explicit constexpr fp_simd_type (value_types && ... vals) noexcept
            : _vec {
                static_cast <value_type> (std::forward <value_types> (vals))...
            }
        {}

        constexpr fp_simd_type (fp_simd_type const & sv) noexcept
            : base {}
            , _vec {sv._vec}
        {}

        explicit constexpr fp_simd_type (value_type const (&arr) [lanes])
            noexcept
            : _vec {base::unpack (arr)}
        {}

        explicit constexpr
        fp_simd_type (std::array <value_type, lanes> const & arr) noexcept
            : _vec {base::unpack (arr)}
        {}

        advanced_constexpr fp_simd_type &
            operator= (fp_simd_type const & sv) & noexcept
        {
            this->_vec = sv._vec;
            return *this;
        }

        template <typename U>
        advanced_constexpr fp_simd_type & operator= (U val) & noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            this->_vec = base::extend (val);
            return *this;
        }

    private:
        template <std::size_t ... L>
        advanced_constexpr void
            fill_array (std::array <value_type, lanes> & arr,
                        util::index_sequence <L...>) const noexcept
        {
            value_type _unused [] = {
                (std::get <L> (arr) = this->template get <L> ())...
            };
            (void) _unused;
        }

    public:
        explicit advanced_constexpr
            operator std::array <value_type, lanes> (void) const noexcept
        {
            std::array <value_type, lanes> result {};
            this->fill_array (result, util::make_index_sequence <lanes> {});
            return result;
        }

    private:
        template <typename vec_from, typename valtype>
        static vec_from vector_convert (vec_from const & v) noexcept
        {
            return v;
        }

        template <typename vec_to, typename valtype, typename vec_from>
        static vec_to vector_convert (vec_from const & v) noexcept
        {
#if defined (__clang__)
            return static_cast <vec_to> (v);
#elif defined (__GNUG__)
            return base::template vector_convert <vec_to, valtype> (
                v, util::lane_tag <lanes> {}
            );
#endif
        }

    public:
        template <typename SimdT>
        constexpr SimdT to (void) const noexcept
        {
            static_assert (
                is_simd_type <SimdT>::value,
                "cannot perform cast to non-simd type"
            );

            using cast_traits = simd_traits <SimdT>;
            using rebind_type = rebind <
                typename cast_traits::value_type,
                cast_traits::lanes,
                typename cast_traits::category_tag
            >;
            using rebind_vector_type = typename rebind_type::vector_type;
            using rebind_value_type = typename rebind_type::value_type;

            static_assert (
                lanes == cast_traits::lanes,
                "cannot perform conversion of vector type to vector type with a"
                " different number of lanes"
            );

            return rebind_type {
                vector_convert <rebind_vector_type, rebind_value_type> (
                    this->_vec
                )
            };
        }

        template <typename SimdT>
        constexpr operator SimdT (void) const noexcept
        {
            return this->template to <SimdT> ();
        }

        template <typename SimdT>
        SimdT as (void) const noexcept
        {
            static_assert (
                is_simd_type <SimdT>::value,
                "cannot perform cast to non-simd type"
            );

            using cast_traits = simd_traits <SimdT>;
            using rebind_type = rebind <
                typename cast_traits::value_type,
                cast_traits::lanes,
                typename cast_traits::category_tag
            >;
            using rebind_vector_type = typename rebind_type::vector_type;

            static_assert (
                sizeof (vector_type) == sizeof (rebind_vector_type),
                "cannot reinterpret vector to differently sized vector type"
            );

            return rebind_type {
                reinterpret_cast <rebind_vector_type> (this->_vec)
            };
        }

        advanced_constexpr void swap (fp_simd_type & other) noexcept
        {
            auto tmp = *this;
            *this = other;
            other = tmp;
        }

        advanced_constexpr vector_type & data (void) & noexcept
        {
            return this->_vec;
        }

        constexpr vector_type const & data (void) const & noexcept
        {
            return this->_vec;
        }

        constexpr value_type value (std::size_t n) const noexcept
        {
            return this->_vec [n];
        }

        advanced_constexpr void fill (value_type const & val) & noexcept
        {
            this->_vec = base::extend (val);
        }

        advanced_constexpr void
            assign (std::size_t n, value_type const & val) & noexcept
        {
            this->_vec [n] = val;
        }

        advanced_constexpr void
            assign (std::initializer_list <value_type> & vl) & noexcept
        {
            auto vals = vl.begin ();
            std::size_t i = 0;
            for (; i < std::min (lanes, vl.size ()); ++i) {
                this->_vec [i] = vals [i];
            }
            for (; i < lanes; ++i) {
                this->_vec [i] = value_type {0};
            }
        }

        template <std::size_t n>
        constexpr const_reference get (void) const & noexcept
        {
            static_assert (
                n < lanes,
                "cannot access out-of-bounds vector lane"
            );

            return const_reference {
                &this->_vec, static_cast <std::ptrdiff_t> (n)
            };
        }

        template <std::size_t n>
        advanced_constexpr reference get (void) & noexcept
        {
            static_assert (
                n < lanes,
                "cannot access out-of-bounds vector lane"
            );

            return reference {&this->_vec, static_cast <std::ptrdiff_t> (n)};
        }

        template <std::size_t n>
        advanced_constexpr fp_simd_type & set (value_type const & val) &
            noexcept
        {
            static_assert (
                n < lanes,
                "cannot access out-of-bounds vector lane"
            );

            this->_vec [n] = val;
            return *this;
        }

        constexpr const_reference operator[] (std::size_t n) const & noexcept
        {
            return const_reference {
                &this->_vec, static_cast <std::ptrdiff_t> (n)
            };
        }

        advanced_constexpr reference operator[] (std::size_t n) & noexcept
        {
            return reference {
                &this->_vec, static_cast <std::ptrdiff_t> (n)
            };
        }

        constexpr const_reference at (std::size_t n) const &
        {
            return n < lanes ?
                const_reference {this->_vec, n} :
                throw std::out_of_range {
                    "access attempt to out-of-bounds vector lane"
                };
        }

        advanced_constexpr reference at (std::size_t n) &
        {
            return n < lanes ?
                reference {this->_vec, n} :
                throw std::out_of_range {
                    "access attempt to out-of-bounds vector lane"
                };
        }

        advanced_constexpr iterator begin (void) & noexcept
        {
            return iterator {this->data (), 0};
        }

        advanced_constexpr iterator end (void) & noexcept
        {
            return iterator {
                this->data (), static_cast <std::ptrdiff_t> (lanes)
            };
        }

        constexpr const_iterator begin (void) const & noexcept
        {
            return const_iterator {this->data (), 0};
        }

        constexpr const_iterator end (void) const & noexcept
        {
            return const_iterator {
                this->data (), static_cast <std::ptrdiff_t> (lanes)
            };
        }

        constexpr const_iterator cbegin (void) const & noexcept
        {
            return const_iterator {this->data (), 0};
        }

        constexpr const_iterator cend (void) const & noexcept
        {
            return const_iterator {
                this->data (), static_cast <std::ptrdiff_t> (lanes)
            };
        }

        advanced_constexpr reverse_iterator rbegin (void) & noexcept
        {
            return reverse_iterator {
                this->data (), static_cast <std::ptrdiff_t> (lanes)
            };
        }

        advanced_constexpr reverse_iterator rend (void) & noexcept
        {
            return reverse_iterator {this->data (), 0};
        }

        constexpr const_reverse_iterator rbegin (void) const & noexcept
        {
            return const_reverse_iterator {
                this->data (), static_cast <std::ptrdiff_t> (lanes)
            };
        }

        constexpr const_reverse_iterator rend (void) const & noexcept
        {
            return const_reverse_iterator {this->data (), 0};
        }

        constexpr const_reverse_iterator crbegin (void) const & noexcept
        {
            return const_reverse_iterator {
                this->data (), static_cast <std::ptrdiff_t> (lanes)
            };
        }

        constexpr const_reverse_iterator crend (void) const & noexcept
        {
            return const_reverse_iterator {this->data (), 0};
        }

        constexpr fp_simd_type operator+ (void) const noexcept
        {
            return fp_simd_type {+this->_vec};
        }

        constexpr fp_simd_type operator- (void) const noexcept
        {
            return fp_simd_type {-this->_vec};
        }

        constexpr fp_simd_type operator+ (fp_simd_type const & sv) const
            noexcept
        {
            return fp_simd_type {this->_vec + sv._vec};
        }

        template <typename U>
        constexpr fp_simd_type operator+ (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return fp_simd_type {
                this->_vec + base::extend (val)
            };
        }

        constexpr fp_simd_type operator- (fp_simd_type const & sv) const
            noexcept
        {
            return fp_simd_type {this->_vec - sv._vec};
        }

        template <typename U>
        constexpr fp_simd_type operator- (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return fp_simd_type {
                this->_vec - base::extend (val)
            };
        }

        constexpr fp_simd_type operator* (fp_simd_type const & sv) const
            noexcept
        {
            return fp_simd_type {this->_vec * sv._vec};
        }

        template <typename U>
        constexpr fp_simd_type operator* (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return fp_simd_type {
                this->_vec * base::extend (val)
            };
        }

        constexpr fp_simd_type operator/ (fp_simd_type const & sv) const
            noexcept
        {
            return fp_simd_type {this->_vec / sv._vec};
        }

        template <typename U>
        constexpr fp_simd_type operator/ (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return fp_simd_type {
                this->_vec / base::extend (val)
            };
        }

        constexpr fp_simd_type operator! (void) const noexcept
        {
            return fp_simd_type {!this->_vec};
        }

        constexpr fp_simd_type operator&& (fp_simd_type const & sv) const
            noexcept
        {
            return fp_simd_type {this->_vec && sv._vec};
        }

        template <typename U>
        constexpr fp_simd_type operator&& (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return fp_simd_type {
                this->_vec && base::extend (val)
            };
        }

        constexpr fp_simd_type operator|| (fp_simd_type const & sv) const
            noexcept
        {
            return fp_simd_type {this->_vec || sv._vec};
        }

        template <typename U>
        constexpr fp_simd_type operator|| (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return fp_simd_type {
                this->_vec || base::extend (val)
            };
        }

        advanced_constexpr fp_simd_type & operator+= (fp_simd_type const & sv) & noexcept
        {
            this->_vec += sv._vec;
            return *this;
        }

        template <typename U>
        advanced_constexpr fp_simd_type & operator+= (U val) & noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            this->_vec += base::extend (val);
            return *this;
        }

        advanced_constexpr fp_simd_type & operator-= (fp_simd_type const & sv) & noexcept
        {
            this->_vec -= sv._vec;
            return *this;
        }

        template <typename U>
        advanced_constexpr fp_simd_type & operator-= (U val) & noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            this->_vec -= base::extend (val);
            return *this;
        }

        advanced_constexpr fp_simd_type & operator*= (fp_simd_type const & sv) & noexcept
        {
            this->_vec *= sv._vec;
            return *this;
        }

        template <typename U>
        advanced_constexpr fp_simd_type & operator*= (U val) & noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            this->_vec *= base::extend (val);
            return *this;
        }

        advanced_constexpr fp_simd_type & operator/= (fp_simd_type const & sv) &
            noexcept
        {
            this->_vec /= sv._vec;
            return *this;
        }

        template <typename U>
        advanced_constexpr fp_simd_type & operator/= (U val) & noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            this->_vec /= base::extend (val);
            return *this;
        }

#if defined (__clang__)
    private:
        template <typename Comparison, std::size_t ... L>
        static constexpr boolean_simd_type <integral_type, lanes>
            unpack_comparison (Comparison && c, util::index_sequence <L...>)
            noexcept
        {
            return boolean_simd_type <integral_type, lanes> {
                std::forward <Comparison> (c) [L]...
            };
        }

    public:
#endif
        constexpr boolean_simd_type <integral_type, lanes>
            operator== (fp_simd_type const & sv) const noexcept
        {
#if defined (__clang__)
            return unpack_comparison (
                this->_vec == sv._vec, util::make_index_sequence <lanes> {}
            );
#elif defined (__GNUG__)
            return boolean_simd_type <integral_type, lanes> {
                this->_vec == sv._vec
            };
#endif
        }

        template <typename U>
        constexpr boolean_simd_type <integral_type, lanes> operator== (U val)
            const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return *this == fp_simd_type {val};
        }

        constexpr boolean_simd_type <integral_type, lanes>
            operator!= (fp_simd_type const & sv) const noexcept
        {
#if defined (__clang__)
            return unpack_comparison (
                this->_vec != sv._vec, util::make_index_sequence <lanes> {}
            );
#elif defined (__GNUG__)
            return boolean_simd_type <integral_type, lanes> {
                this->_vec != sv._vec
            };
#endif
        }

        template <typename U>
        constexpr boolean_simd_type <integral_type, lanes>
            operator!= (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return *this != fp_simd_type {val};
        }

        constexpr boolean_simd_type <integral_type, lanes>
            operator> (fp_simd_type const & sv) const noexcept
        {
#if defined (__clang__)
            return unpack_comparison (
                this->_vec > sv._vec, util::make_index_sequence <lanes> {}
            );
#elif defined (__GNUG__)
            return boolean_simd_type <integral_type, lanes> {
                this->_vec > sv._vec
            };
#endif
        }

        template <typename U>
        constexpr boolean_simd_type <integral_type, lanes>
            operator> (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return *this > fp_simd_type {val};
        }

        constexpr boolean_simd_type <integral_type, lanes>
            operator< (fp_simd_type const & sv) const noexcept
        {
#if defined (__clang__)
            return unpack_comparison (
                this->_vec < sv._vec, util::make_index_sequence <lanes> {}
            );
#elif defined (__GNUG__)
            return boolean_simd_type <integral_type, lanes> {
                this->_vec < sv._vec
            };
#endif
        }

        template <typename U>
        constexpr boolean_simd_type <integral_type, lanes>
            operator< (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return *this < fp_simd_type {val};
        }

        constexpr boolean_simd_type <integral_type, lanes>
            operator>= (fp_simd_type const & sv) const noexcept
        {
#if defined (__clang__)
            return unpack_comparison (
                this->_vec >= sv._vec, util::make_index_sequence <lanes> {}
            );
#elif defined (__GNUG__)
            return boolean_simd_type <integral_type, lanes> {
                this->_vec >= sv._vec
            };
#endif
        }

        template <typename U>
        constexpr boolean_simd_type <integral_type, lanes>
            operator>= (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return *this >= fp_simd_type {val};
        }

        constexpr boolean_simd_type <integral_type, lanes>
            operator<= (fp_simd_type const & sv) const noexcept
        {
#if defined (__clang__)
            return unpack_comparison (
                this->_vec <= sv._vec, util::make_index_sequence <lanes> {}
            );
#elif defined (__GNUG__)
            return boolean_simd_type <integral_type, lanes> {
                this->_vec <= sv._vec
            };
#endif
        }

        template <typename U>
        constexpr boolean_simd_type <integral_type, lanes>
            operator<= (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return *this <= fp_simd_type {val};
        }
    };
#pragma GCC diagnostic pop

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wattributes"
    template <typename T, std::size_t l>
    class alignas (simd_type_base <std::complex <T>, l>::alignment)
        complex_simd_type : public simd_type_base <std::complex <T>, l>
    {
    private:
        using base = simd_type_base <std::complex <T>, l>;

        typename base::vector_type_impl _realvec;
        typename base::vector_type_impl _imagvec;

        /*
         * This is a proxy reference object to avoid undefined behavior and
         * type-punning in derived SIMD type classes. It is the returned
         * type from methds such as operator[] and at().
         */
        template <typename VecType, typename ValType>
        class reference_proxy;

        /*
         * This is a proxy pointer object to avoid undefined behavior and
         * type-punning in derived SIMD type classes. It is the returned
         * type from methds such as {c}{r}begin and {c}{r}end.
         */
        template <typename VecType, typename ValType>
        class pointer_proxy;

        template <typename VecType, typename ValType>
        class reference_proxy
        {
        private:
            using vector_type = VecType;
            using value_type  = ValType;
            using pointer     = pointer_proxy <vector_type, value_type>;
            using vecpointer  = typename std::add_pointer <vector_type>::type;

            vecpointer _realref;
            vecpointer _imagref;
            std::ptrdiff_t _index;

        public:
            reference_proxy (void) = delete;
            ~reference_proxy (void) noexcept = default;

            constexpr reference_proxy (vecpointer real,
                                       vecpointer imag,
                                       std::ptrdiff_t index = 0)
                noexcept
                : _realref {real}
                , _imagref {imag}
                , _index   {index}
            {}

            constexpr
                reference_proxy (vector_type & real,
                                 vector_type & imag,
                                 std::ptrdiff_t index = 0)
                noexcept
                : _realref {&real}
                , _imagref {&imag}
                , _index   {index}
            {}

            constexpr reference_proxy (reference_proxy const &) noexcept
                = default;

            template <typename U>
            reference_proxy & operator= (U && u) noexcept
            {
                static_assert (
                    std::is_convertible <U, value_type>::value,
                    "cannot assign to vector lane from non-convertible type"
                );

                (*this->_realref) [this->_index] = static_cast <value_type> (
                    std::forward <U> (u)
                ).real ();
                (*this->_imagref) [this->_index] = static_cast <value_type> (
                    std::forward <U> (u)
                ).imag ();
                return *this;
            }

            reference_proxy & operator= (reference_proxy const & r) noexcept
            {
                this->_realref = r._realref;
                this->_imagref = r._imagref;
                this->_index = r._index;
                return *this;
            }

            void swap (reference_proxy & r) noexcept
            {
                std::swap (this->_realref, r._realref);
                std::swap (this->_imagref, r._imagref);
                std::swap (this->_index, r._index);
            }

            template <typename U>
            constexpr operator U (void) const noexcept
            {
                static_assert (
                    std::is_convertible <value_type, U>::value,
                    "cannot perform cast"
                );

                return static_cast <U> (
                    value_type {
                        (*this->_realref) [this->_index],
                        (*this->_imagref) [this->_index]
                    }
                );
            }

            pointer operator& (void) const & noexcept
            {
                return pointer {this->_realref, this->_imagref, this->_index};
            }

            constexpr bool operator== (reference_proxy const & r) const noexcept
            {
                return (*this->_realref) [this->_index] == (*r._realref) [r._index] &&
                       (*this->_imagref) [this->_index] == (*r._imagref) [r._index];
            }

            constexpr bool operator!= (reference_proxy const & r) const noexcept
            {
                return (*this->_realref) [this->_index] != (*r._realref) [r._index] ||
                       (*this->_imagref) [this->_index] != (*r._imagref) [r._index];
            }
        };

        template <typename VecType, typename ValType>
        class pointer_proxy
        {
        private:
            using vector_type = VecType;
            using value_type  = ValType;
            using vecpointer  = typename std::add_pointer <vector_type>::type;
            using reference   = reference_proxy <vector_type, value_type>;

            vecpointer _realpointer;
            vecpointer _imagpointer;
            std::ptrdiff_t _index;

        public:
            using iterator_category = std::random_access_iterator_tag;

            constexpr pointer_proxy (void) noexcept
                : _realpointer {nullptr}
                , _imagpointer {nullptr}
                , _index       {0}
            {}

            ~pointer_proxy (void) noexcept = default;

            constexpr pointer_proxy (vecpointer real,
                                     vecpointer imag,
                                     std::ptrdiff_t index = 0)
                noexcept
                : _realpointer {real}
                , _imagpointer {imag}
                , _index       {index}
            {}

            constexpr pointer_proxy (vector_type & real,
                                     vector_type & imag,
                                     std::ptrdiff_t index = 0)
                noexcept
                : _realpointer {&real}
                , _imagpointer {&imag}
                , _index       {index}
            {}

            constexpr pointer_proxy (pointer_proxy const &) noexcept = default;

            advanced_constexpr pointer_proxy & operator= (pointer_proxy p)
                noexcept
            {
                this->_realpointer = p._realpointer;
                this->_imagpointer = p._imagpointer;
                this->_index = p._index;
                return *this;
            }

            operator bool (void) noexcept
            {
                return static_cast <bool> (this->_realpointer) &&
                       static_cast <bool> (this->_imagpointer);
            }

            reference operator* (void) const noexcept
            {
                return reference {
                    this->_realpointer, this->_imagpointer, this->_index
                };
            }

            reference operator[] (std::ptrdiff_t n) const noexcept
            {
                return reference {
                    this->_realpointer, this->_imagpointer, this->_index + n
                };
            }

            pointer_proxy & operator++ (void) noexcept
            {
                this->_index += 1;
                return *this;
            }

            pointer_proxy & operator-- (void) noexcept
            {
                this->_index -= 1;
                return *this;
            }

            pointer_proxy operator++ (int) noexcept
            {
                auto const tmp = *this;
                this->_index += 1;
                return tmp;
            }

            pointer_proxy operator-- (int) noexcept
            {
                auto const tmp = *this;
                this->_index -= 1;
                return tmp;
            }

            pointer_proxy & operator+= (std::ptrdiff_t n) noexcept
            {
                this->_index += n;
                return *this;
            }

            pointer_proxy & operator-= (std::ptrdiff_t n) noexcept
            {
                this->_index -= n;
                return *this;
            }

            pointer_proxy operator+ (std::ptrdiff_t n) const noexcept
            {
                auto tmp = *this;
                return tmp += n;
            }

            pointer_proxy operator- (std::ptrdiff_t n) const noexcept
            {
                auto tmp = *this;
                return tmp -= n;
            }

            std::ptrdiff_t operator- (pointer_proxy p) const noexcept
            {
                return this->_index - p._index;
            }

            bool operator== (pointer_proxy p) const noexcept
            {
                return this->_realpointer == p._realpointer &&
                       this->_imagpointer == p._imagpointer &&
                       this->_index == p._index;
            }

            bool operator!= (pointer_proxy p) const noexcept
            {
                return this->_realpointer != p._realpointer ||
                       this->_imagpointer != p._imagpointer ||
                       this->_index != p._index;
            }

            bool operator< (pointer_proxy p) const noexcept
            {
                return (this->_realpointer < p._realpointer &&
                        this->_imagpointer < p._imagpointer)||
                       (this->_realpointer == p._realpointer &&
                        this->_imagpointer == p._imagpointer &&
                        this->_index < p._index);
            }

            bool operator> (pointer_proxy p) const noexcept
            {
                return (this->_realpointer > p._realpointer &&
                        this->_imagpointer > p._imagpointer)||
                       (this->_realpointer == p._realpointer &&
                        this->_imagpointer == p._imagpointer &&
                        this->_index > p._index);
            }

            bool operator<= (pointer_proxy p) const noexcept
            {
                return *this == p || *this < p;
            }

            bool operator>= (pointer_proxy p) const noexcept
            {
                return *this == p || *this > p;
            }
        };

    public:
        static_assert (
            std::is_floating_point <T>::value,
            "template parameter typename T must be a floating point type"
        );

        using vector_type     = typename base::vector_type_impl;
        using value_type      = std::complex <T>;
        using integral_type   = typename base::integral_type;
        using unsigned_integral_type = typename base::unsigned_integral_type;
        using signed_integral_type = typename base::signed_integral_type;
        using reference       = reference_proxy <vector_type, value_type>;
        using const_reference =
            reference_proxy <vector_type const, value_type const>;
        using iterator        = pointer_proxy <vector_type, value_type>;
        using const_iterator =
            pointer_proxy <vector_type const, value_type const>;
        using reverse_iterator       = std::reverse_iterator <iterator>;
        using const_reverse_iterator = std::reverse_iterator <const_iterator>;
        using category_tag           = complex_tag;
        static constexpr std::size_t lanes = l;
        static constexpr std::size_t alignment = base::alignment;
        static constexpr std::size_t size = 2 * sizeof (vector_type);

        template <typename U, std::size_t L, typename tag>
        using rebind = simd_type <U, L, tag>;

        static void * operator new (std::size_t sz)
        {
            if (sz != size) {
                /* let standard new handle an incorrect size request */
                return ::operator new (sz);
            } else {
                return util::aligned_allocate (sz, alignment);
            }
        }

        static void * operator new [] (std::size_t sz)
        {
            return util::aligned_allocate (sz ? sz : size, alignment);
        }

/* overloads for C++17 operator new with alignement spec */
#if __cplusplus > 201402L
        static void * operator new (std::size_t sz, std::align_val_t al)
        {
            return ::operator new (sz, al)};
        }

        static void * operator new [] (std::size_t sz, std::align_val_t al)
        {
            return ::operator new [] (sz, al);
        }
#endif

#if __cplusplus >= 201402L
        static void operator delete (void * ptr, std::size_t sz) noexcept
#else
        static void operator delete (void * ptr) noexcept
#endif
        {
#if __cplusplus < 201402L
            std::size_t sz {size};
#endif
            if (ptr == nullptr) {
                return;
            } else if (sz != size) {
                /* let ::delete handle incorrectly sized delete requests */
#if __cplusplus >= 201402L
                ::operator delete (ptr, sz);
#else
                ::operator delete (ptr);
#endif
            } else {
                util::aligned_deallocate (ptr, sz, alignment);
            }
        }

#if __cplusplus >= 201402L
        static void operator delete [] (void * ptr, std::size_t sz) noexcept
#else
        static void operator delete [] (void * ptr) noexcept
#endif
        {
#if __cplusplus < 201402L
            std::size_t sz {size};
#endif
            if (ptr == nullptr) {
                return;
            } else if (!sz) {
                /* let ::delete handle incorrectly sized delete requests */
#if __cplusplus >= 201402L
                ::operator delete (ptr, sz);
#else
                ::operator delete (ptr);
#endif
            } else {
                util::aligned_deallocate (ptr, sz, alignment);
            }
        }

/* overloads for C++17 operator delete with alignment spec */
#if __cplusplus > 201402L
        static void
            operator delete (void * ptr, std::size_t sz, std::align_val_t al)
            noexcept
        {
            ::operator delete (ptr, sz, al);
        }

        static void
            operator delete [] (void * ptr, std::size_t sz, std::align_val_t al)
            noexcept
        {
            ::operator delete [] (ptr, sz, al);
        }
#endif

    private:
        template <std::size_t ... L>
        static constexpr vector_type
            unpack_real_impl (value_type const (& arr) [lanes],
                              util::index_sequence <L...>) noexcept
        {
            return vector_type {arr [L].real ()...};
        }

        template <std::size_t ... L>
        static constexpr vector_type
            unpack_real_impl (std::array <value_type, lanes> const & arr,
                              util::index_sequence <L...>) noexcept
        {
            return vector_type {std::get <L> (arr).real ()...};
        }

        template <std::size_t ... L>
        static constexpr vector_type
            unpack_imag_impl (value_type const (& arr) [lanes],
                              util::index_sequence <L...>) noexcept
        {
            return vector_type {arr [L].imag ()...};
        }

        template <std::size_t ... L>
        static constexpr vector_type
            unpack_imag_impl (std::array <value_type, lanes> const & arr,
                              util::index_sequence <L...>) noexcept
        {
            return vector_type {std::get <L> (arr).imag ()...};
        }

        template <std::size_t ... L>
        static constexpr vector_type
            extend_impl (T const & t, util::index_sequence <L...>) noexcept
        {
            return vector_type {((void) L, t)...};
        }

        static constexpr vector_type
            unpack_real (value_type const (& arr) [lanes]) noexcept
        {
            return unpack_real_impl (arr, util::make_index_sequence <lanes> {});
        }

        static constexpr vector_type
            unpack_imag (value_type const (& arr) [lanes]) noexcept
        {
            return unpack_imag_impl (arr, util::make_index_sequence <lanes> {});
        }

        static constexpr vector_type
            unpack_real (std::array <value_type, lanes> const & arr) noexcept
        {
            return unpack_real_impl (arr, util::make_index_sequence <lanes> {});
        }

        static constexpr vector_type
            unpack_imag (std::array <value_type, lanes> const & arr) noexcept
        {
            return unpack_imag_impl (arr, util::make_index_sequence <lanes> {});
        }

        static constexpr vector_type extend (T const & t) noexcept
        {
            return extend_impl (t, util::make_index_sequence <lanes> {});
        }

        template <
            typename ... Ts,
            typename = typename std::enable_if <
                sizeof... (Ts) == lanes && lanes != 1
            >::type
        >
        static constexpr vector_type extend (Ts const & ... ts)
            noexcept
        {
            return vector_type {ts...};
        }

    public:
        static complex_simd_type load (value_type const * addr) noexcept
        {
            complex_simd_type result {};
            for (std::size_t i = 0; i < lanes; ++i) {
                result._realvec [i] = *addr++;
                result._imagvec [i] = *addr++;
            }
            return result;
        }

        static complex_simd_type load (value_type const * addr,
                                       std::ptrdiff_t off) noexcept
        {
            auto use_addr = addr + off;

            complex_simd_type result {};
            for (std::size_t i = 0; i < lanes; ++i) {
                result._realvec [i] = *use_addr++;
                result._imagvec [i] = *use_addr++;
            }
            return result;
        }

        static complex_simd_type load (vector_type const * real_addr,
                                       vector_type const * imag_addr) noexcept
        {
            return complex_simd_type {*real_addr, *imag_addr};
        }

        static complex_simd_type load (vector_type const * real_addr,
                                       vector_type const * imag_addr,
                                       std::ptrdiff_t real_off,
                                       std::ptrdiff_t imag_off = real_off)
            noexcept
        {
            return complex_simd_type {
                *(real_addr + real_off), *(imag_addr + imag_off)
            };
        }

        static complex_simd_type load_aligned (value_type const * addr) noexcept
        {
            auto aligned_ptr = static_cast <value_type const *> (
                __builtin_assume_aligned (addr, base::alignment)
            );

            complex_simd_type result {};
            for (std::size_t i = 0; i < lanes; ++i) {
                result._realvec [i] = *aligned_ptr++;
                result._imagvec [i] = *aligned_ptr++;
            }
            return result;
        }

        static complex_simd_type load_aligned (value_type const * addr,
                                               std::ptrdiff_t off) noexcept
        {
            auto use_addr = addr + off;
            auto aligned_ptr = static_cast <value_type const *> (
                __builtin_assume_aligned (use_addr, base::alignment)
            );

            complex_simd_type result {};
            for (std::size_t i = 0; i < lanes; ++i) {
                result._realvec [i] = *aligned_ptr++;
                result._imagvec [i] = *aligned_ptr++;
            }
            return result;
        }

        static complex_simd_type load_aligned (vector_type const * real_addr,
                                               vector_type const * imag_addr)
            noexcept
        {
            auto aligned_real_ptr = static_cast <vector_type const *> (
                __builtin_assume_aligned (real_addr, base::alignment)
            );
            auto aligned_imag_ptr = static_cast <vector_type const *> (
                __builtin_assume_aligned (imag_addr, base::alignment)
            );

            return complex_simd_type {*aligned_real_ptr, *aligned_imag_ptr};
        }

        static complex_simd_type
            load_aligned (vector_type const * real_addr,
                          vector_type const * imag_addr,
                          std::ptrdiff_t real_off,
                          std::ptrdiff_t imag_off = real_off)
            noexcept
        {
            auto real_use_addr = real_addr + real_off;
            auto imag_use_addr = imag_addr + imag_off;

            auto aligned_real_ptr = static_cast <vector_type const *> (
                __builtin_assume_aligned (real_use_addr, base::alignment)
            );
            auto aligned_imag_ptr = static_cast <vector_type const *> (
                __builtin_assume_aligned (imag_use_addr, base::alignment)
            );

            return complex_simd_type {*aligned_real_ptr, *aligned_imag_ptr};
        }

        constexpr complex_simd_type (void) noexcept
            : _realvec {extend (value_type {}.real ())}
            , _imagvec {extend (value_type {}.imag ())}
        {}

        explicit constexpr
            complex_simd_type (vector_type const & realvec,
                               vector_type const & imagvec) noexcept
            : _realvec {realvec}
            , _imagvec {imagvec}
        {}

        explicit constexpr complex_simd_type (value_type const & val) noexcept
            : _realvec {extend (val.real ())}
            , _imagvec {extend (val.imag ())}
        {}

        template <
            typename ... value_types,
            typename = typename std::enable_if <
                sizeof... (value_types) == lanes && lanes != 1
            >::type
        >
        explicit constexpr complex_simd_type (value_types && ... vals) noexcept
            : _realvec {
                extend (
                    static_cast <value_type> (
                        std::forward <value_types> (vals)
                    ).real ()...
                )
            }
            , _imagvec {
                extend (
                    static_cast <value_type> (
                        std::forward <value_types> (vals)
                    ).imag ()...
                )
            }
        {}

        constexpr
        complex_simd_type (complex_simd_type const & sv)
            noexcept
            : base {}
            , _realvec {sv._realvec}
            , _imagvec {sv._imagvec}
        {}

        explicit constexpr
        complex_simd_type (value_type const (& arr) [lanes]) noexcept
            : _realvec {unpack_real (arr)}
            , _imagvec {unpack_imag (arr)}
        {}

        explicit constexpr
        complex_simd_type (std::array <value_type, lanes> const & arr) noexcept
            : _realvec {unpack_real (arr)}
            , _imagvec {unpack_imag (arr)}
        {}

        advanced_constexpr complex_simd_type &
            operator= (complex_simd_type const & sv) & noexcept
        {
            this->_realvec = sv._realvec;
            this->_imagvec = sv._imagvec;
            return *this;
        }

        template <typename U>
        advanced_constexpr complex_simd_type & operator= (U val) & noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            this->_realvec = extend (static_cast <value_type> (val).real ());
            this->_imagvec = extend (static_cast <value_type> (val).imag ());
            return *this;
        }

    private:
        template <std::size_t ... L>
        advanced_constexpr void
            fill_array (std::array <value_type, lanes> & arr,
                        util::index_sequence <L...>) const noexcept
        {
            value_type _unused [] = {
                (std::get <L> (arr) = this->template get <L> ())...
            };
            (void) _unused;
        }

    public:
        explicit advanced_constexpr
            operator std::array <value_type, lanes> (void) const noexcept
        {
            std::array <value_type, lanes> result {};
            this->fill_array (result, util::make_index_sequence <lanes> {});
            return result;
        }

    private:
        template <typename vec_from, typename valtype>
        static vec_from vector_convert (vec_from const & v) noexcept
        {
            return v;
        }

        template <typename vec_to, typename valtype, typename vec_from>
        static vec_to vector_convert (vec_from const & v) noexcept
        {
#if defined (__clang__)
            return static_cast <vec_to> (v);
#elif defined (__GNUG__)
            return base::template vector_convert <vec_to, valtype> (
                v, util::lane_tag <lanes> {}
            );
#endif
        }

    public:
        template <typename SimdT>
        advanced_constexpr SimdT to (void) const noexcept
        {
            static_assert (
                is_simd_type <SimdT>::value,
                "cannot perform cast to non-simd type"
            );

            using cast_traits = simd_traits <SimdT>;
            using rebind_type = rebind <
                typename cast_traits::value_type,
                cast_traits::lanes,
                typename cast_traits::category_tag
            >;
            using rebind_vector_type = typename rebind_type::vector_type;
            using rebind_value_type = typename rebind_type::value_type;

            static_assert (
                2 * lanes == cast_traits::lanes,
                "cannot perform conversion of vector type to vector type with a"
                " different number of lanes"
            );

            std::array <rebind_value_type, cast_traits::lanes> result {};
            for (std::size_t i = 0; i < lanes; ++i) {
                result [2*i] = static_cast <rebind_value_type> (
                    this->_realvec [i]
                );
                result [2*i + 1] = static_cast <rebind_value_type> (
                    this->_imagvec [i]
                );
            }
            return rebind_type {result};
        }

        template <typename SimdT>
        advanced_constexpr operator SimdT (void) const noexcept
        {
            return this->template to <SimdT> ();
        }

        advanced_constexpr void swap (complex_simd_type & other) noexcept
        {
            auto tmp = *this;
            *this = other;
            other = tmp;
        }

        advanced_constexpr void fill (value_type const & val) noexcept
        {
            this->_realvec = extend (val.real ());
            this->_realvec = extend (val.imag ());
        }

        advanced_constexpr void
            assign (std::size_t n, value_type const & val) & noexcept
        {
            this->_realvec [n] = val.real ();
            this->_imagvec [n] = val.imag ();
        }

        advanced_constexpr void
            assign (std::initializer_list <value_type> & vl) & noexcept
        {
            auto vals = vl.begin ();
            std::size_t i = 0;
            for (; i < std::min (lanes, vl.size ()); ++i) {
                this->_realvec [i] = vals [i].real ();
                this->_imagvec [i] = vals [i].imag ();
            }
            for (; i < lanes; ++i) {
                this->_realvec [i] = value_type {0}.real ();
                this->_imagvec [i] = value_type {0}.imag ();
            }
        }

        constexpr std::pair <vector_type const &, vector_type const &>
            data (void) const & noexcept
        {
            return std::pair <vector_type const &, vector_type const &> (
                this->_realvec, this->_imagvec
            );
        }

        advanced_constexpr std::pair <vector_type &, vector_type &>
            data (void) & noexcept
        {
            return std::pair <vector_type &, vector_type &> (
                this->_realvec, this->_imagvec
            );
        }

        constexpr value_type value (std::size_t n) const noexcept
        {
            return value_type {this->_realvec [n], this->_imagvec [n]};
        }

        template <std::size_t n>
        constexpr const_reference get (void) const & noexcept
        {
            static_assert (
                n < lanes,
                "cannot access out-of-bounds vector lane"
            );

            return const_reference {
                this->_realvec, this->_imagvec, static_cast <std::ptrdiff_t> (n)
            };
        }

        template <std::size_t n>
        advanced_constexpr reference get (void) & noexcept
        {
            static_assert (
                n < lanes,
                "cannot access out-of-bounds vector lane"
            );

            return reference {
                this->_realvec, this->_imagvec, static_cast <std::ptrdiff_t> (n)
            };
        }

        template <std::size_t n>
        advanced_constexpr complex_simd_type set (value_type const & val) &
            noexcept
        {
            static_assert (
                n < lanes,
                "cannot access out-of-bounds vector lane"
            );

            this->_realvec [n] = val.real ();
            this->_imagvec [n] = val.imag ();
            return *this;
        }

        constexpr const_reference
            operator[] (std::size_t n) const & noexcept
        {
            return const_reference {
                this->_realvec, this->_imagvec, static_cast <std::ptrdiff_t> (n)
            };
        }

        advanced_constexpr reference operator[] (std::size_t n) & noexcept
        {
            return reference {
                this->_realvec, this->_imagvec, static_cast <std::ptrdiff_t> (n)
            };
        }

        constexpr const_reference at (std::size_t n) const &
        {
            return n < lanes ?
                const_reference {
                    this->_realvec, this->_imagvec,
                    static_cast <std::ptrdiff_t> (n)
                } :
                throw std::out_of_range {
                    "access attempt to out-of-bounds vector lane"
                };
        }

        advanced_constexpr reference at (std::size_t n) &
        {
            return n < lanes ?
                reference {
                    this->_realvec, this->_imagvec,
                    static_cast <std::ptrdiff_t> (n)
                } :
                throw std::out_of_range {
                    "access attempt to out-of-bounds vector lane"
                };
        }

        advanced_constexpr iterator begin (void) & noexcept
        {
            return iterator {this->_realvec, this->_imagvec, 0};
        }

        advanced_constexpr iterator end (void) & noexcept
        {
            return iterator {
                this->_realvec, this->_imagvec,
                static_cast <std::ptrdiff_t> (lanes)
            };
        }

        constexpr const_iterator begin (void) const & noexcept
        {
            return const_iterator {this->_realvec, this->_imagvec, 0};
        }

        constexpr const_iterator end (void) const & noexcept
        {
            return const_iterator {
                this->_realvec, this->_imagvec,
                static_cast <std::ptrdiff_t> (lanes)
            };
        }

        constexpr const_iterator cbegin (void) const & noexcept
        {
            return const_iterator {this->_realvec, this->_imagvec, 0};
        }

        constexpr const_iterator cend (void) const & noexcept
        {
            return const_iterator {
                this->_realvec, this->_imagvec,
                static_cast <std::ptrdiff_t> (lanes)
            };
        }

        advanced_constexpr reverse_iterator rbegin (void) & noexcept
        {
            return reverse_iterator {
                this->_realvec, this->_imagvec,
                static_cast <std::ptrdiff_t> (lanes)
            };
        }

        advanced_constexpr reverse_iterator rend (void) & noexcept
        {
            return reverse_iterator {this->_realvec, this->_imagvec, 0};
        }

        constexpr const_reverse_iterator rbegin (void) const & noexcept
        {
            return const_reverse_iterator {
                this->_realvec, this->_imagvec,
                static_cast <std::ptrdiff_t> (lanes)
            };
        }

        constexpr const_reverse_iterator rend (void) const & noexcept
        {
            return const_reverse_iterator {this->_realvec, this->_imagvec, 0};
        }

        constexpr const_reverse_iterator crbegin (void) const & noexcept
        {
            return const_reverse_iterator {
                this->_realvec, this->_imagvec,
                static_cast <std::ptrdiff_t> (lanes)
            };
        }

        constexpr const_reverse_iterator crend (void) const & noexcept
        {
            return const_reverse_iterator {this->_realvec, this->_imagvec, 0};
        }

        constexpr complex_simd_type operator+ (void) const noexcept
        {
            return complex_simd_type {+this->_realvec, +this->_imagvec};
        }

        constexpr complex_simd_type operator- (void) const noexcept
        {
            return complex_simd_type {-this->_realvec, -this->_imagvec};
        }

        constexpr
        complex_simd_type operator+ (complex_simd_type const & sv) const
            noexcept
        {
            return complex_simd_type {
                this->_realvec + sv._realvec, this->_imagvec + sv._imagvec
            };
        }

        template <typename U>
        constexpr complex_simd_type operator+ (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return *this + complex_simd_type {val};
        }

        constexpr complex_simd_type operator- (complex_simd_type const & sv)
            const noexcept
        {
            return complex_simd_type {
                this->_realvec - sv._realvec, this->_imagvec - sv._imagvec
            };
        }

        template <typename U>
        constexpr complex_simd_type operator- (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return *this - complex_simd_type {val};
        }

        advanced_constexpr complex_simd_type operator* (complex_simd_type const & sv)
            const noexcept
        {
            auto const realmul = this->_realvec * sv._realvec;
            auto const imagmul = this->_imagvec * sv._imagvec;
            auto const real_part = realmul - imagmul;

            auto const crossmul_1 = this->_realvec * sv._imagvec;
            auto const crossmul_2 = this->_imagvec * sv._realvec;
            auto const imag_part = crossmul_1 + crossmul_2;

            return complex_simd_type {real_part, imag_part};
        }

        template <typename U>
        constexpr complex_simd_type operator* (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return *this * complex_simd_type {val};
        }

        advanced_constexpr complex_simd_type operator/ (complex_simd_type const & sv)
            const noexcept
        {
            auto const divisor = sv._realvec * sv._realvec + sv._imagvec * sv._imagvec;

            auto const realmul = this->_realvec * sv._realvec;
            auto const imagmul = this->_imagvec * sv._imagvec;
            auto const real_part = (realmul + imagmul) / divisor;

            auto const crossmul_1 = this->_imagvec * sv._realvec;
            auto const crossmul_2 = this->_realvec * sv._imagvec;
            auto const imag_part = (crossmul_1 - crossmul_2) / divisor;

            return complex_simd_type {real_part, imag_part};
        }

        template <typename U>
        constexpr complex_simd_type operator/ (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return *this / complex_simd_type {val};
        }

        advanced_constexpr
        complex_simd_type & operator+= (complex_simd_type const & sv) &
            noexcept
        {
            this->_realvec += sv._realvec;
            this->_imagvec += sv._imagvec;
            return *this;
        }

        template <typename U>
        advanced_constexpr complex_simd_type & operator+= (U val) & noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            complex_simd_type const v {val};
            return *this += v;
        }

        advanced_constexpr
        complex_simd_type & operator-= (complex_simd_type const & sv) &
            noexcept
        {
            this->_realvec -= sv._realvec;
            this->_imagvec -= sv._imagvec;
            return *this;
        }

        template <typename U>
        advanced_constexpr complex_simd_type & operator-= (U val) & noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            complex_simd_type const v {val};
            return *this -= v;
        }

        advanced_constexpr
        complex_simd_type & operator*= (complex_simd_type const & sv) &
            noexcept
        {
            auto const result = *this * sv;
            *this = result;
            return *this;
        }

        template <typename U>
        advanced_constexpr complex_simd_type & operator*= (U val) & noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            complex_simd_type const v {val};
            auto const result = *this * v;
            *this = result;
            return *this;
        }

        advanced_constexpr
        complex_simd_type & operator/= (complex_simd_type const & sv) &
            noexcept
        {
            auto const result = *this / sv;
            *this = result;
            return *this;
        }

        template <typename U>
        advanced_constexpr complex_simd_type & operator/= (U val) & noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            complex_simd_type const v {val};
            auto const result = *this / v;
            *this = result;
            return *this;
        }

#if defined (__clang__)
    private:
        template <typename Comparison, std::size_t ... L>
        static constexpr boolean_simd_type <integral_type, lanes>
            unpack_comparison (Comparison && c, util::index_sequence <L...>)
            noexcept
        {
            return boolean_simd_type <integral_type, lanes> {
                std::forward <Comparison> (c) [L]...
            };
        }

    public:
#endif
        constexpr boolean_simd_type <integral_type, lanes>
            operator== (complex_simd_type const & sv) const noexcept
        {
#if defined (__clang__)
            return unpack_comparison (
                this->_realvec == sv._realvec &&
                this->_imagvec == sv._imagvec,
                util::make_index_sequence <lanes> {}
            );
#elif defined (__GNUG__)
            return boolean_simd_type <integral_type, lanes> {
                this->_realvec == sv._realvec &&
                this->_imagvec == sv._imagvec
            };
#endif
        }

        template <typename U>
        constexpr boolean_simd_type <integral_type, lanes> operator== (U val)
            const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return *this == complex_simd_type {val};
        }

        constexpr boolean_simd_type <integral_type, lanes>
            operator!= (complex_simd_type const & sv) const noexcept
        {
#if defined (__clang__)
            return unpack_comparison (
                this->_realvec != sv._realvec ||
                this->_imagvec != sv._imagvec,
                util::make_index_sequence <lanes> {}
            );
#elif defined (__GNUG__)
            return boolean_simd_type <integral_type, lanes> {
                this->_realvec != sv._realvec ||
                this->_imagvec != sv._imagvec
            };
#endif
        }

        template <typename U>
        constexpr boolean_simd_type <integral_type, lanes>
            operator!= (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return *this != complex_simd_type {val};
        }
    };
#pragma GCC diagnostic pop

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wattributes"
    template <typename T, std::size_t l>
    class alignas (simd_type_base <T, l>::alignment)
        boolean_simd_type : public simd_type_base <T, l>
    {
    private:
        using base = simd_type_base <T, l>;

        typename base::vector_type_impl _vec;

    public:
        using vector_type            = typename base::vector_type_impl;
        using value_type             = bool;
        using integral_type          = typename base::integral_type;
        using unsigned_integral_type = typename base::unsigned_integral_type;
        using signed_integral_type   = typename base::signed_integral_type;
        using reference              = typename base::reference;
        using const_reference        = typename base::const_reference;
        using iterator               = typename base::pointer;
        using const_iterator         = typename base::const_pointer;
        using reverse_iterator       = std::reverse_iterator <iterator>;
        using const_reverse_iterator = std::reverse_iterator <const_iterator>;
        static constexpr std::size_t lanes = l;

        template <typename U, std::size_t L, typename tag>
        using rebind = simd_type <U, L, tag>;

        static boolean_simd_type load (value_type const * addr) noexcept
        {
            boolean_simd_type result;
            for (std::size_t i = 0; i < lanes; ++i) {
                result._vec [i] = *addr++;
            }
            return result;
        }

        static boolean_simd_type load (value_type const * addr,
                                       std::ptrdiff_t off) noexcept
        {
            auto use_addr = addr + off;

            boolean_simd_type result;
            for (std::size_t i = 0; i < lanes; ++i) {
                result._vec [i] = *use_addr++;
            }
            return result;
        }

        static boolean_simd_type load (vector_type const * addr) noexcept
        {
            return boolean_simd_type {*addr};
        }

        static boolean_simd_type load (vector_type const * addr,
                                       std::ptrdiff_t off) noexcept
        {
            return boolean_simd_type {*(addr + off)};
        }

        static boolean_simd_type load_aligned (value_type const * addr)
            noexcept
        {
            auto aligned_ptr = static_cast <value_type const *> (
                __builtin_assume_aligned (addr, base::alignment)
            );

            boolean_simd_type result;
            for (std::size_t i = 0; i < lanes; ++i) {
                result._vec [i] = *aligned_ptr++;
            }
            return result;
        }

        static boolean_simd_type load_aligned (value_type const * addr,
                                               std::ptrdiff_t off) noexcept
        {
            auto use_addr = addr + off;
            auto aligned_ptr = static_cast <value_type const *> (
                __builtin_assume_aligned (use_addr, base::alignment)
            );

            boolean_simd_type result;
            for (std::size_t i = 0; i < lanes; ++i) {
                result._vec [i] = *aligned_ptr++;
            }
            return result;
        }

        static boolean_simd_type load_aligned (vector_type const * addr)
            noexcept
        {
            auto aligned_ptr = static_cast <vector_type const *> (
                __builtin_assume_aligned (addr, base::alignment)
            );

            return boolean_simd_type {*aligned_ptr};
        }

        static boolean_simd_type load_aligned (vector_type const * addr,
                                               std::ptrdiff_t off) noexcept
        {
            auto use_addr = addr + off;
            auto aligned_ptr = static_cast <vector_type const *> (
                __builtin_assume_aligned (use_addr, base::alignment)
            );

            return boolean_simd_type {*aligned_ptr};
        }

        static constexpr vector_type make_gcc_compatible (vector_type const & v)
            noexcept
        {
#if defined (__clang__)
            using uvector_type = vext::vector <unsigned_integral_type, lanes>;

            return __builtin_convertvector (
                __builtin_convertvector (v * -1, uvector_type), vector_type
            );
#elif defined (__GNUG__)
            return v ? ~integral_type {0} : integral_type {0};
#endif
        }

        constexpr boolean_simd_type (void) noexcept
            : _vec {base::extend (value_type {0})}
        {}

        explicit constexpr boolean_simd_type (vector_type const & vec) noexcept
#if defined (__clang__)
            : _vec {vec}
#elif defined (__GNUG__)
            : _vec {vec & integral_type {1}}
#endif
        {}

        explicit constexpr boolean_simd_type (value_type const & val) noexcept
            : _vec {base::extend (val)}
        {}

        template <
            typename ... value_types,
            typename = typename std::enable_if <
                sizeof... (value_types) == lanes && lanes != 1
            >::type
        >
        explicit constexpr boolean_simd_type (value_types && ... vals) noexcept
            : _vec {
                static_cast <value_type> (std::forward <value_types> (vals))...
            }
        {}

        constexpr boolean_simd_type (boolean_simd_type const & sv) noexcept
            : base {}
            , _vec {sv._vec}
        {}

        explicit constexpr boolean_simd_type (value_type const (&arr) [lanes])
            noexcept
            : _vec {base::unpack (arr)}
        {}

        explicit constexpr
        boolean_simd_type (std::array <value_type, lanes> const & arr) noexcept
            : _vec {base::unpack (arr)}
        {}

        advanced_constexpr boolean_simd_type &
            operator= (boolean_simd_type const & sv) & noexcept
        {
            this->_vec = sv._vec;
            return *this;
        }

        template <typename U>
        advanced_constexpr boolean_simd_type & operator= (U val) & noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            this->_vec = base::extend (val);
            return *this;
        }

    private:
        template <std::size_t ... L>
        advanced_constexpr void
            fill_array (std::array <value_type, lanes> & arr,
                        util::index_sequence <L...>) const noexcept
        {
            value_type _unused [] = {
                (std::get <L> (arr) = this->template get <L> ())...
            };
            (void) _unused;
        }

    public:
        explicit advanced_constexpr
            operator std::array <value_type, lanes> (void) const noexcept
        {
            std::array <value_type, lanes> result {};
            this->fill_array (result, util::make_index_sequence <lanes> {});
            return result;
        }

    private:
        template <typename vec_from, typename valtype>
        static vec_from vector_convert (vec_from const & v) noexcept
        {
            return v;
        }

        template <typename vec_to, typename valtype, typename vec_from>
        static vec_to vector_convert (vec_from const & v) noexcept
        {
#if defined (__clang__)
            return static_cast <vec_to> (v);
#elif defined (__GNUG__)
            return base::template vector_convert <vec_to, valtype> (
                v, util::lane_tag <lanes> {}
            );
#endif
        }

    public:
        template <typename SimdT>
        constexpr SimdT to (void) const noexcept
        {
            static_assert (
                is_simd_type <SimdT>::value,
                "cannot perform cast to non-simd type"
            );

            using cast_traits = simd_traits <SimdT>;
            using rebind_type = rebind <
                typename cast_traits::value_type,
                cast_traits::lanes,
                typename cast_traits::category_tag
            >;
            using rebind_vector_type = typename rebind_type::vector_type;
            using rebind_value_type = typename rebind_type::value_type;

            static_assert (
                lanes == cast_traits::lanes,
                "cannot perform conversion of vector type to vector type with a"
                " different number of lanes"
            );

            return rebind_type {
                vector_convert <rebind_vector_type, rebind_value_type> (
                    this->_vec
                )
            };
        }

        template <typename SimdT>
        constexpr operator SimdT (void) const noexcept
        {
            return this->template to <SimdT> ();
        }

        template <typename SimdT>
        SimdT as (void) const noexcept
        {
            static_assert (
                is_simd_type <SimdT>::value,
                "cannot perform cast to non-simd type"
            );

            using cast_traits = simd_traits <SimdT>;
            using rebind_type = rebind <
                typename cast_traits::value_type,
                cast_traits::lanes,
                typename cast_traits::category_tag
            >;
            using rebind_vector_type = typename rebind_type::vector_type;

            static_assert (
                sizeof (vector_type) == sizeof (rebind_vector_type),
                "cannot reinterpret vector to differently sized vector type"
            );

            return rebind_type {
                reinterpret_cast <rebind_vector_type> (this->_vec)
            };
        }

        advanced_constexpr void swap (boolean_simd_type & other) noexcept
        {
            auto tmp = *this;
            *this = other;
            other = tmp;
        }

        advanced_constexpr vector_type & data (void) & noexcept
        {
            return this->_vec;
        }

        constexpr vector_type const & data (void) const & noexcept
        {
            return this->_vec;
        }

        constexpr value_type value (std::size_t n) const noexcept
        {
            return this->_vec [n];
        }

        advanced_constexpr void fill (value_type const & val) & noexcept
        {
            this->_vec = base::extend (val);
        }

        advanced_constexpr void
            assign (std::size_t n, value_type const & val) & noexcept
        {
            this->_vec [n] = val;
        }

        advanced_constexpr void
            assign (std::initializer_list <value_type> & vl) & noexcept
        {
            auto vals = vl.begin ();
            std::size_t i = 0;
            for (; i < std::min (lanes, vl.size ()); ++i) {
                this->_vec [i] = vals [i];
            }
            for (; i < lanes; ++i) {
                this->_vec [i] = value_type {0};
            }
        }

        template <std::size_t n>
        constexpr const_reference get (void) const & noexcept
        {
            static_assert (
                n < lanes,
                "cannot access out-of-bounds vector lane"
            );

            return const_reference {
                &this->_vec, static_cast <std::ptrdiff_t> (n)
            };
        }

        template <std::size_t n>
        advanced_constexpr reference get (void) & noexcept
        {
            static_assert (
                n < lanes,
                "cannot access out-of-bounds vector lane"
            );

            return reference {&this->_vec, static_cast <std::ptrdiff_t> (n)};
        }

        template <std::size_t n>
        advanced_constexpr boolean_simd_type & set (value_type const & val) &
            noexcept
        {
            static_assert (
                n < lanes,
                "cannot access out-of-bounds vector lane"
            );

            this->_vec [n] = val;
            return *this;
        }

        constexpr const_reference operator[] (std::size_t n) const & noexcept
        {
            return const_reference {
                &this->_vec, static_cast <std::ptrdiff_t> (n)
            };
        }

        advanced_constexpr reference operator[] (std::size_t n) & noexcept
        {
            return reference {
                &this->_vec, static_cast <std::ptrdiff_t> (n)
            };
        }

        constexpr const_reference at (std::size_t n) const &
        {
            return n < lanes ?
                const_reference {this->_vec, n} :
                throw std::out_of_range {
                    "access attempt to out-of-bounds vector lane"
                };
        }

        advanced_constexpr reference at (std::size_t n) &
        {
            return n < lanes ?
                reference {this->_vec, n} :
                throw std::out_of_range {
                    "access attempt to out-of-bounds vector lane"
                };
        }

        advanced_constexpr iterator begin (void) & noexcept
        {
            return iterator {this->data (), 0};
        }

        advanced_constexpr iterator end (void) & noexcept
        {
            return iterator {
                this->data (), static_cast <std::ptrdiff_t> (lanes)
            };
        }

        constexpr const_iterator begin (void) const & noexcept
        {
            return const_iterator {this->data (), 0};
        }

        constexpr const_iterator end (void) const & noexcept
        {
            return const_iterator {
                this->data (), static_cast <std::ptrdiff_t> (lanes)
            };
        }

        constexpr const_iterator cbegin (void) const & noexcept
        {
            return const_iterator {this->data (), 0};
        }

        constexpr const_iterator cend (void) const & noexcept
        {
            return const_iterator {
                this->data (), static_cast <std::ptrdiff_t> (lanes)
            };
        }

        advanced_constexpr reverse_iterator rbegin (void) & noexcept
        {
            return reverse_iterator {
                this->data (), static_cast <std::ptrdiff_t> (lanes)
            };
        }

        advanced_constexpr reverse_iterator rend (void) & noexcept
        {
            return reverse_iterator {this->data (), 0};
        }

        constexpr const_reverse_iterator rbegin (void) const & noexcept
        {
            return const_reverse_iterator {
                this->data (), static_cast <std::ptrdiff_t> (lanes)
            };
        }

        constexpr const_reverse_iterator rend (void) const & noexcept
        {
            return const_reverse_iterator {this->data (), 0};
        }

        constexpr const_reverse_iterator crbegin (void) const & noexcept
        {
            return const_reverse_iterator {
                this->data (), static_cast <std::ptrdiff_t> (lanes)
            };
        }

        constexpr const_reverse_iterator crend (void) const & noexcept
        {
            return const_reverse_iterator {this->data (), 0};
        }

    private:
        constexpr bool any_of_impl (util::lane_tag <1>) const noexcept
        {
            return static_cast <bool> (this->_vec [0]);
        }

        constexpr bool any_of_impl (util::lane_tag <2>) const noexcept
        {
            return this->_vec [0] || this->_vec [1];
        }

        constexpr bool any_of_impl (util::lane_tag <4>) const noexcept
        {
            return
                this->_vec [0] || this->_vec [1] ||
                this->_vec [2] || this->_vec [3];
        }

        constexpr bool any_of_impl (util::lane_tag <8>) const noexcept
        {
            return
                this->_vec [0] || this->_vec [1] ||
                this->_vec [2] || this->_vec [3] ||
                this->_vec [4] || this->_vec [5] ||
                this->_vec [6] || this->_vec [7];
        }

        constexpr bool any_of_impl (util::lane_tag <16>) const noexcept
        {
            return
                this->_vec [0]  || this->_vec [1]  ||
                this->_vec [2]  || this->_vec [3]  ||
                this->_vec [4]  || this->_vec [5]  ||
                this->_vec [6]  || this->_vec [7]  ||
                this->_vec [8]  || this->_vec [9]  ||
                this->_vec [10] || this->_vec [11] ||
                this->_vec [12] || this->_vec [13] ||
                this->_vec [14] || this->_vec [15];
        }

        constexpr bool any_of_impl (util::lane_tag <32>) const noexcept
        {
            return
                this->_vec [0]  || this->_vec [1]  ||
                this->_vec [2]  || this->_vec [3]  ||
                this->_vec [4]  || this->_vec [5]  ||
                this->_vec [6]  || this->_vec [7]  ||
                this->_vec [8]  || this->_vec [9]  ||
                this->_vec [10] || this->_vec [11] ||
                this->_vec [12] || this->_vec [13] ||
                this->_vec [14] || this->_vec [15] ||
                this->_vec [16] || this->_vec [17] ||
                this->_vec [18] || this->_vec [19] ||
                this->_vec [20] || this->_vec [21] ||
                this->_vec [22] || this->_vec [23] ||
                this->_vec [24] || this->_vec [25] ||
                this->_vec [26] || this->_vec [27] ||
                this->_vec [28] || this->_vec [29] ||
                this->_vec [30] || this->_vec [31];
        }

        constexpr bool any_of_impl (util::lane_tag <64>) const noexcept
        {
            return
                this->_vec [0]  || this->_vec [1]  ||
                this->_vec [2]  || this->_vec [3]  ||
                this->_vec [4]  || this->_vec [5]  ||
                this->_vec [6]  || this->_vec [7]  ||
                this->_vec [8]  || this->_vec [9]  ||
                this->_vec [10] || this->_vec [11] ||
                this->_vec [12] || this->_vec [13] ||
                this->_vec [14] || this->_vec [15] ||
                this->_vec [16] || this->_vec [17] ||
                this->_vec [18] || this->_vec [19] ||
                this->_vec [20] || this->_vec [21] ||
                this->_vec [22] || this->_vec [23] ||
                this->_vec [24] || this->_vec [25] ||
                this->_vec [26] || this->_vec [27] ||
                this->_vec [28] || this->_vec [29] ||
                this->_vec [30] || this->_vec [31] ||
                this->_vec [32] || this->_vec [33] ||
                this->_vec [34] || this->_vec [35] ||
                this->_vec [36] || this->_vec [37] ||
                this->_vec [38] || this->_vec [39] ||
                this->_vec [40] || this->_vec [41] ||
                this->_vec [42] || this->_vec [43] ||
                this->_vec [44] || this->_vec [45] ||
                this->_vec [46] || this->_vec [47] ||
                this->_vec [48] || this->_vec [49] ||
                this->_vec [50] || this->_vec [51] ||
                this->_vec [52] || this->_vec [53] ||
                this->_vec [54] || this->_vec [55] ||
                this->_vec [56] || this->_vec [57] ||
                this->_vec [58] || this->_vec [59] ||
                this->_vec [60] || this->_vec [61] ||
                this->_vec [62] || this->_vec [63];
        }

        constexpr bool all_of_impl (util::lane_tag <1>) const noexcept
        {
            return static_cast <bool> (this->_vec [0]);
        }

        constexpr bool all_of_impl (util::lane_tag <2>) const noexcept
        {
            return this->_vec [0] && this->_vec [1];
        }

        constexpr bool all_of_impl (util::lane_tag <4>) const noexcept
        {
            return
                this->_vec [0] && this->_vec [1] &&
                this->_vec [2] && this->_vec [3];
        }

        constexpr bool all_of_impl (util::lane_tag <8>) const noexcept
        {
            return
                this->_vec [0] && this->_vec [1] &&
                this->_vec [2] && this->_vec [3] &&
                this->_vec [4] && this->_vec [5] &&
                this->_vec [6] && this->_vec [7];
        }

        constexpr bool all_of_impl (util::lane_tag <16>) const noexcept
        {
            return
                this->_vec [0]  && this->_vec [1]  &&
                this->_vec [2]  && this->_vec [3]  &&
                this->_vec [4]  && this->_vec [5]  &&
                this->_vec [6]  && this->_vec [7]  &&
                this->_vec [8]  && this->_vec [9]  &&
                this->_vec [10] && this->_vec [11] &&
                this->_vec [12] && this->_vec [13] &&
                this->_vec [14] && this->_vec [15];
        }

        constexpr bool all_of_impl (util::lane_tag <32>) const noexcept
        {
            return
                this->_vec [0]  && this->_vec [1]  &&
                this->_vec [2]  && this->_vec [3]  &&
                this->_vec [4]  && this->_vec [5]  &&
                this->_vec [6]  && this->_vec [7]  &&
                this->_vec [8]  && this->_vec [9]  &&
                this->_vec [10] && this->_vec [11] &&
                this->_vec [12] && this->_vec [13] &&
                this->_vec [14] && this->_vec [15] &&
                this->_vec [16] && this->_vec [17] &&
                this->_vec [18] && this->_vec [19] &&
                this->_vec [20] && this->_vec [21] &&
                this->_vec [22] && this->_vec [23] &&
                this->_vec [24] && this->_vec [25] &&
                this->_vec [26] && this->_vec [27] &&
                this->_vec [28] && this->_vec [29] &&
                this->_vec [30] && this->_vec [31];
        }

        constexpr bool all_of_impl (util::lane_tag <64>) const noexcept
        {
            return
                this->_vec [0]  && this->_vec [1]  &&
                this->_vec [2]  && this->_vec [3]  &&
                this->_vec [4]  && this->_vec [5]  &&
                this->_vec [6]  && this->_vec [7]  &&
                this->_vec [8]  && this->_vec [9]  &&
                this->_vec [10] && this->_vec [11] &&
                this->_vec [12] && this->_vec [13] &&
                this->_vec [14] && this->_vec [15] &&
                this->_vec [16] && this->_vec [17] &&
                this->_vec [18] && this->_vec [19] &&
                this->_vec [20] && this->_vec [21] &&
                this->_vec [22] && this->_vec [23] &&
                this->_vec [24] && this->_vec [25] &&
                this->_vec [26] && this->_vec [27] &&
                this->_vec [28] && this->_vec [29] &&
                this->_vec [30] && this->_vec [31] &&
                this->_vec [32] && this->_vec [33] &&
                this->_vec [34] && this->_vec [35] &&
                this->_vec [36] && this->_vec [37] &&
                this->_vec [38] && this->_vec [39] &&
                this->_vec [40] && this->_vec [41] &&
                this->_vec [42] && this->_vec [43] &&
                this->_vec [44] && this->_vec [45] &&
                this->_vec [46] && this->_vec [47] &&
                this->_vec [48] && this->_vec [49] &&
                this->_vec [50] && this->_vec [51] &&
                this->_vec [52] && this->_vec [53] &&
                this->_vec [54] && this->_vec [55] &&
                this->_vec [56] && this->_vec [57] &&
                this->_vec [58] && this->_vec [59] &&
                this->_vec [60] && this->_vec [61] &&
                this->_vec [62] && this->_vec [63];
        }

        constexpr bool none_of_impl (util::lane_tag <1>) const noexcept
        {
            return !this->any_of_impl (util::lane_tag <1> {});
        }

        constexpr bool none_of_impl (util::lane_tag <2>) const noexcept
        {
            return !this->any_of_impl (util::lane_tag <2> {});
        }

        constexpr bool none_of_impl (util::lane_tag <4>) const noexcept
        {
            return !this->any_of_impl (util::lane_tag <4> {});
        }

        constexpr bool none_of_impl (util::lane_tag <8>) const noexcept
        {
            return !this->any_of_impl (util::lane_tag <8> {});
        }

        constexpr bool none_of_impl (util::lane_tag <16>) const noexcept
        {
            return !this->any_of_impl (util::lane_tag <16> {});
        }

        constexpr bool none_of_impl (util::lane_tag <32>) const noexcept
        {
            return !this->any_of_impl (util::lane_tag <32> {});
        }

        constexpr bool none_of_impl (util::lane_tag <64>) const noexcept
        {
            return !this->any_of_impl (util::lane_tag <64> {});
        }

    public:
        constexpr bool any_of (void) const noexcept
        {
            return this->any_of_impl (util::lane_tag <lanes> {});
        }

        advanced_constexpr bool all_of (void) const noexcept
        {
            return this->all_of_impl (util::lane_tag <lanes> {});
        }

        advanced_constexpr bool none_of (void) const noexcept
        {
            return this->none_of_impl (util::lane_tag <lanes> {});
        }

    private:
        template <std::size_t ... L>
        constexpr boolean_simd_type normalize_impl (util::index_sequence <L...>)
            const noexcept
        {
            return boolean_simd_type {
                (this->_vec [L] ? integral_type {1} : integral_type {0})...
            };
        }

    public:
        constexpr boolean_simd_type normalize (void) const noexcept
        {
            return this->normalize_impl (util::make_index_sequence <lanes> {});
        }

        constexpr integral_simd_type <integral_type, lanes> to_integral (void)
            const noexcept
        {
            using cast_vector_type =
                typename integral_simd_type <integral_type, lanes>::vector_type;

            return integral_simd_type <integral_type, lanes> {
                static_cast <cast_vector_type> (this->_vec)
            };
        }

        constexpr boolean_simd_type operator~ (void) const noexcept
        {
            return boolean_simd_type {~this->_vec};
        }

        constexpr boolean_simd_type operator& (boolean_simd_type const & sv)
            const noexcept
        {
            return boolean_simd_type {this->_vec & sv._vec};
        }

        template <typename U>
        constexpr boolean_simd_type operator& (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return boolean_simd_type {
                this->_vec & base::extend (val)
            };
        }

        constexpr boolean_simd_type operator| (boolean_simd_type const & sv)
            const noexcept
        {
            return boolean_simd_type {this->_vec | sv._vec};
        }

        template <typename U>
        constexpr boolean_simd_type operator| (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return boolean_simd_type {
                this->_vec | base::extend (val)
            };
        }

        constexpr boolean_simd_type operator^ (boolean_simd_type const & sv)
            const noexcept
        {
            return boolean_simd_type {this->_vec ^ sv._vec};
        }

        template <typename U>
        constexpr boolean_simd_type operator^ (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return boolean_simd_type {
                this->_vec ^ base::extend (val)
            };
        }

        constexpr boolean_simd_type operator! (void) const noexcept
        {
            return boolean_simd_type {!this->_vec};
        }

        constexpr boolean_simd_type operator&& (boolean_simd_type const & sv)
            const noexcept
        {
            return boolean_simd_type {this->_vec && sv._vec};
        }

        template <typename U>
        constexpr boolean_simd_type operator&& (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return boolean_simd_type {
                this->_vec && base::extend (val)
            };
        }

        constexpr boolean_simd_type operator|| (boolean_simd_type const & sv)
            const noexcept
        {
            return boolean_simd_type {this->_vec || sv._vec};
        }

        template <typename U>
        constexpr boolean_simd_type operator|| (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return boolean_simd_type {
                this->_vec || base::extend (val)
            };
        }

        advanced_constexpr boolean_simd_type &
            operator&= (boolean_simd_type const & sv) & noexcept
        {
            this->_vec &= sv._vec;
            return *this;
        }

        template <typename U>
        advanced_constexpr boolean_simd_type & operator&= (U val) & noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            this->_vec &= base::extend (val);
            return *this;
        }

        advanced_constexpr boolean_simd_type &
            operator|= (boolean_simd_type const & sv) & noexcept
        {
            this->_vec |= sv._vec;
            return *this;
        }

        template <typename U>
        advanced_constexpr boolean_simd_type & operator|= (U val) & noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            this->_vec |= base::extend (val);
            return *this;
        }

        advanced_constexpr boolean_simd_type &
            operator^= (boolean_simd_type const & sv) & noexcept
        {
            this->_vec ^= sv._vec;
            return *this;
        }

        template <typename U>
        advanced_constexpr boolean_simd_type & operator^= (U val) & noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            this->_vec ^= base::extend (val);
            return *this;
        }

#if defined (__clang__)
    private:
        template <typename Comparison, std::size_t ... L>
        static constexpr boolean_simd_type
            unpack_comparison (Comparison && c, util::index_sequence <L...>)
            noexcept
        {
            return boolean_simd_type <integral_type, lanes> {
                std::forward <Comparison> (c) [L]...
            };
        }

    public:
#endif
        constexpr boolean_simd_type operator== (boolean_simd_type const & sv)
            const noexcept
        {
#if defined (__clang__)
            return unpack_comparison (
                this->_vec == sv._vec, util::make_index_sequence <lanes> {}
            );
#elif defined (__GNUG__)
            return boolean_simd_type {this->_vec == sv._vec};
#endif
        }

        template <typename U>
        constexpr boolean_simd_type operator== (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return *this == boolean_simd_type {val};
        }

        constexpr boolean_simd_type operator!= (boolean_simd_type const & sv)
            const noexcept
        {
#if defined (__clang__)
            return unpack_comparison (
                this->_vec != sv._vec, util::make_index_sequence <lanes> {}
            );
#elif defined (__GNUG__)
            return boolean_simd_type {this->_vec != sv._vec};
#endif
        }

        template <typename U>
        constexpr boolean_simd_type
            operator!= (U val) const noexcept
        {
            static_assert (
                std::is_convertible <U, value_type>::value,
                "cannot perform operation between vector type and scalar type"
                " without conversion"
            );

            return *this != boolean_simd_type {val};
        }
    };
#pragma GCC diagnostic pop
}   // namespace detail

    template <typename SimdT>
    struct simd_traits : public detail::simd_traits <SimdT> {};

    template <typename SimdT>
    struct simd_traits <SimdT const> : public simd_traits <SimdT>
    {};

    template <typename SimdT>
    struct simd_traits <SimdT &> : public simd_traits <SimdT>
    {};

    template <typename SimdT>
    struct simd_traits <SimdT &&> : public simd_traits <SimdT>
    {};

    template <typename SimdT>
    struct simd_traits <SimdT const &> : public simd_traits <SimdT>
    {};

    using arithmetic_tag = detail::arithmetic_tag;
    using complex_tag = detail::complex_tag;
    using boolean_tag = detail::boolean_tag;

    template <typename T, std::size_t lanes, typename tag = arithmetic_tag>
    using simd_type = detail::simd_type <T, lanes, tag>;

    template <typename SimdT>
    SimdT load (typename simd_traits <SimdT>::value_type const * addr) noexcept
    {
        return SimdT::load (addr);
    }

    template <typename SimdT>
    SimdT load (typename simd_traits <SimdT>::value_type const * addr,
                std::ptrdiff_t off) noexcept
    {
        return SimdT::load (addr, off);
    }

    template <typename SimdT>
    SimdT load (typename simd_traits <SimdT>::vector_type const * addr) noexcept
    {
        return SimdT::load (addr);
    }

    template <typename SimdT>
    SimdT load (typename simd_traits <SimdT>::vector_type const * addr,
                std::ptrdiff_t off) noexcept
    {
        return SimdT::load (addr, off);
    }

    template <typename SimdT>
    SimdT load_aligned (typename simd_traits <SimdT>::value_type const * addr)
        noexcept
    {
        return SimdT::load_aligned (addr);
    }

    template <typename SimdT>
    SimdT load_aligned (typename simd_traits <SimdT>::value_type const * addr,
                        std::ptrdiff_t off) noexcept
    {
        return SimdT::load_aligned (addr, off);
    }

    template <typename SimdT>
    SimdT load_aligned (typename simd_traits <SimdT>::vector_type const * addr)
        noexcept
    {
        return SimdT::load_aligned (addr);
    }

    template <typename SimdT>
    SimdT load_aligned (typename simd_traits <SimdT>::vector_type const * addr,
                        std::ptrdiff_t off)
        noexcept
    {
        return SimdT::load_aligned (addr, off);
    }

    template <std::size_t n, typename T, std::size_t lanes, typename tag>
    constexpr typename simd_type <T, lanes, tag>::const_reference
        get (simd_type <T, lanes, tag> const & sv) noexcept
    {
        static_assert (
            n < lanes,
            "cannot access out-of-bounds vector lane"
        );

        return sv.template get <n> ();
    }

    template <std::size_t n, typename T, std::size_t lanes, typename tag>
    constexpr typename simd_type <T, lanes, tag>::reference
        get (simd_type <T, lanes, tag> & sv) noexcept
    {
        static_assert (
            n < lanes,
            "cannot access out-of-bounds vector lane"
        );

        return sv.template get <n> ();
    }

    template <std::size_t n, typename T, std::size_t lanes, typename tag>
    constexpr simd_type <T, lanes, tag> &
        set (simd_type <T, lanes, tag> & sv, T const & val) noexcept
    {
        static_assert (
            n < lanes,
            "cannot access out-of-bounds vector lane"
        );

        return sv.template set <n> (val);
    }

    template <typename SimdT_To, typename SimdT_From>
    constexpr SimdT_To to (SimdT_From const & sv) noexcept
    {
        return sv.template to <SimdT_To> ();
    }

    template <typename SimdT_To, typename SimdT_From>
    SimdT_To as (SimdT_From const & sv) noexcept
    {
        return sv.template as <SimdT_To> ();
    }

    template <typename T, std::size_t lanes, typename tag>
    typename simd_type <T, lanes, tag>::iterator
        begin (simd_type <T, lanes, tag> & sv) noexcept
    {
        return sv.begin ();
    }

    template <typename T, std::size_t lanes, typename tag>
    typename simd_type <T, lanes, tag>::iterator
        end (simd_type <T, lanes, tag> & sv) noexcept
    {
        return sv.end ();
    }

    template <typename T, std::size_t lanes, typename tag>
    typename simd_type <T, lanes, tag>::const_iterator
        begin (simd_type <T, lanes, tag> const & sv) noexcept
    {
        return sv.begin ();
    }

    template <typename T, std::size_t lanes, typename tag>
    typename simd_type <T, lanes, tag>::const_iterator
        end (simd_type <T, lanes, tag> const & sv) noexcept
    {
        return sv.end ();
    }

    template <typename T, std::size_t lanes, typename tag>
    typename simd_type <T, lanes, tag>::const_iterator
        cbegin (simd_type <T, lanes, tag> const & sv) noexcept
    {
        return sv.cbegin ();
    }

    template <typename T, std::size_t lanes, typename tag>
    typename simd_type <T, lanes, tag>::const_iterator
        cend (simd_type <T, lanes, tag> const & sv) noexcept
    {
        return sv.cend ();
    }

    template <typename U, typename T, std::size_t lanes, typename tag>
    constexpr simd_type <T, lanes, tag>
        operator+ (U val, simd_type <T, lanes, tag> const & sv)
    noexcept
    {
        static_assert (
            std::is_convertible <U, T>::value,
            "cannot perform operation between vector type and scalar type"
            " without conversion"
        );

        return sv + val;
    }

    template <typename U, typename T, std::size_t lanes, typename tag>
    constexpr simd_type <T, lanes, tag>
        operator- (U val, simd_type <T, lanes, tag> const & sv)
    noexcept
    {
        static_assert (
            std::is_convertible <U, T>::value,
            "cannot perform operation between vector type and scalar type"
            " without conversion"
        );

        return sv - val;
    }

    template <typename U, typename T, std::size_t lanes, typename tag>
    constexpr simd_type <T, lanes, tag>
        operator* (U val, simd_type <T, lanes, tag> const & sv)
    noexcept
    {
        static_assert (
            std::is_convertible <U, T>::value,
            "cannot perform operation between vector type and scalar type"
            " without conversion"
        );

        return sv * val;
    }

    template <typename U, typename T, std::size_t lanes, typename tag>
    constexpr simd_type <T, lanes, tag>
        operator/ (U val, simd_type <T, lanes, tag> const & sv)
    noexcept
    {
        static_assert (
            std::is_convertible <U, T>::value,
            "cannot perform operation between vector type and scalar type"
            " without conversion"
        );

        return sv / val;
    }

    template <
        typename U, typename T, std::size_t lanes, typename tag,
        typename = typename std::enable_if <std::is_integral <T>::value>::type
    >
    constexpr simd_type <T, lanes, tag>
        operator& (U val, simd_type <T, lanes, tag> const & sv)
    noexcept
    {
        static_assert (
            std::is_convertible <U, T>::value,
            "cannot perform operation between vector type and scalar type"
            " without conversion"
        );

        return sv & val;
    }

    template <
        typename U, typename T, std::size_t lanes, typename tag,
        typename = typename std::enable_if <std::is_integral <T>::value>::type
    >
    constexpr simd_type <T, lanes, tag>
        operator| (U val, simd_type <T, lanes, tag> const & sv)
    noexcept
    {
        static_assert (
            std::is_convertible <U, T>::value,
            "cannot perform operation between vector type and scalar type"
            " without conversion"
        );

        return sv | val;
    }

    template <
        typename U, typename T, std::size_t lanes, typename tag,
        typename = typename std::enable_if <std::is_integral <T>::value>::type
    >
    constexpr simd_type <T, lanes, tag>
        operator^ (U val, simd_type <T, lanes, tag> const & sv)
    noexcept
    {
        static_assert (
            std::is_convertible <U, T>::value,
            "cannot perform operation between vector type and scalar type"
            " without conversion"
        );

        return sv ^ val;
    }

    template <typename U, typename T, std::size_t lanes, typename tag>
    constexpr simd_type <T, lanes, tag>
        operator&& (U val, simd_type <T, lanes, tag> const & sv)
    noexcept
    {
        static_assert (
            std::is_convertible <U, T>::value,
            "cannot perform operation between vector type and scalar type"
            " without conversion"
        );

        return sv && val;
    }

    template <typename U, typename T, std::size_t lanes, typename tag>
    constexpr simd_type <T, lanes, tag>
        operator|| (U val, simd_type <T, lanes, tag> const & sv)
    noexcept
    {
        static_assert (
            std::is_convertible <U, T>::value,
            "cannot perform operation between vector type and scalar type"
            " without conversion"
        );

        return sv || val;
    }

    template <typename U, typename T, std::size_t lanes, typename tag>
    constexpr simd_type <T, lanes, tag>
        operator== (U val, simd_type <T, lanes, tag> const & sv)
    noexcept
    {
        static_assert (
            std::is_convertible <U, T>::value,
            "cannot perform operation between vector type and scalar type"
            " without conversion"
        );

        return sv == val;
    }

    template <typename T, typename U, std::size_t lanes, typename tag>
    simd_type <U, lanes, tag>
        shuffle (simd_type <U, lanes, tag> const & sv,
                 simd_type <T, lanes, tag> const & mask) noexcept
    {
        static_assert (
            std::is_integral <T>::value,
            "template parameter T of mask simd type must be an integral type"
        );

#if defined (__clang__)
    /*
     * clang's __builtin_shufflevector requires constant integer indices,
     * and hence we must implement the function by hand for the general
     * case. For the user of this library this limitation can be overcome by
     * using the .data () method, which provides access to the underlying SIMD
     * vector type.
     */
        simd_type <U, lanes, tag> shuffle_result {};

        for (std::size_t i = 0; i < lanes; ++i) {
            shuffle_result [i] = sv [mask [i]];
        }

        return shuffle_result;
#elif defined (__GNUG__)
        return simd_type <U, lanes, tag> {
            __builtin_shuffle (sv.data (), mask.data ())
        };
#endif
    }

    template <typename T, typename U, std::size_t lanes, typename tag>
    simd_type <U, lanes, tag>
        shuffle (simd_type <U, lanes, tag> const & sv1,
                 simd_type <U, lanes, tag> const & sv2,
                 simd_type <T, lanes, tag> const & mask) noexcept
    {
        static_assert (
            std::is_integral <T>::value,
            "template parameter T of mask simd type must be an integral type"
        );

#if defined (__clang__)
    /*
     * clang's __builtin_shufflevector requires constant integer indices,
     * and hence we must implement the function by hand for the general
     * case. For the user of this library this limitation can be overcome by
     * using the .data () method, which provides access to the underlying SIMD
     * vector type.
     */
        simd_type <U, lanes, tag> shuffle_result {};

        for (std::size_t i = 0; i < lanes; ++i) {
            if (static_cast <std::size_t> (mask [i]) < lanes) {
                shuffle_result [i] = sv1 [mask [i]];
            } else {
                shuffle_result [i] = sv2 [lanes - mask [i]];
            }
        }

        return shuffle_result;
#elif defined (__GNUG__)
        return simd_type <U, lanes, tag> {
            __builtin_shuffle (sv1.data (), sv2.data (), mask.data ())
        };
#endif
    }

    template <typename T, std::size_t lanes>
    constexpr bool any_of (simd_type <T, lanes, boolean_tag> const & boolvec)
        noexcept
    {
        return boolvec.any_of ();
    }

    template <typename T, std::size_t lanes>
    constexpr bool all_of (simd_type <T, lanes, boolean_tag> const & boolvec)
        noexcept
    {
        return boolvec.all_of ();
    }

    template <typename T, std::size_t lanes>
    constexpr bool none_of (simd_type <T, lanes, boolean_tag> const & boolvec)
        noexcept
    {
        return boolvec.none_of ();
    }

    template <typename T, typename U, std::size_t lanes, typename tag>
    simd_type <U, lanes, tag>
        select (simd_type <T, lanes, arithmetic_tag> const & selector,
                simd_type <U, lanes, tag> const & then_vec,
                simd_type <U, lanes, tag> const & else_vec) noexcept
    {
        using select_type = simd_type <T, lanes, boolean_tag>;
        using integral_simd_type = typename select_type::template rebind <
            typename select_type::integral_type, lanes, arithmetic_tag
        >;

        auto const mask = integral_simd_type::increment_vector (lanes) -
                         (selector.to_integral () * integral_simd_type {lanes});
        return shuffle (then_vec, else_vec, mask);
    }

namespace detail
{
    template <typename F, typename SimdT>
    using transform_result = simd_type <
        typename std::result_of <
            F (typename simd_traits <SimdT>::value_type)
        >::type,
        simd_traits <SimdT>::lanes,
        typename simd_traits <SimdT>::category_tag
    >;
}   // namespace detail

    /*
     * Compute a new SIMD vector containing the function results of each lane of
     * the original SIMD vector.
     */
    template <typename F, typename SimdT>
    advanced_constexpr detail::transform_result <F, SimdT>
        transform (F && f, SimdT const & v)
        noexcept (noexcept (
            std::forward <F> (f) (
                std::declval <typename simd_traits <SimdT>::value_type> ()
            )
        ))
    {
        constexpr auto lanes = simd_traits <SimdT>::lanes;

        detail::transform_result <F, SimdT> result {};
        for (std::size_t i = 0; i < lanes; ++i) {
            result [i] = std::forward <F> (f) (v [i]);
        }
        return result;
    }

    /*
     * Compute a new SIMD vector containing the hash values of each lane of the
     * original SIMD vector.
     */
    template <typename SimdT>
    auto hash (SimdT const & v)
        noexcept (noexcept (
            transform (
                std::hash <typename simd_traits <SimdT>::value_type> {}, v
            )
        ))
        -> decltype (
            transform (
                std::hash <typename simd_traits <SimdT>::value_type> {}, v
            )
        )
    {
        return transform (
            std::hash <typename simd_traits <SimdT>::value_type> {}, v
        );
    }

    /*
     * Compute a new SIMD vector containing the hash values of each lane of the
     * original SIMD vector using the provided hash function.
     */
    template <typename HashFn, typename SimdT>
    auto hash (HashFn && hfn, SimdT const & v)
        noexcept (noexcept (transform (std::forward <HashFn> (hfn), v)))
        -> decltype (
            transform (std::forward <HashFn> (hfn), v)
        )
    {
        return transform (std::forward <HashFn> (hfn), v);
    }

    /*
     * Computes the sum across the SIMD vector by the given binary operation.
     */
    template <typename SimdT, typename U, typename BinaryOp>
    U accumulate (SimdT const & v, U init, BinaryOp op)
    {
        return std::accumulate (v.begin (), v.end (), init, op);
    }

    /*
     * Computes the inner product of two arithmetic (non-boolean) SIMD vectors.
     */
    template <typename T, std::size_t lanes>
    T inner_product (simd_type <T, lanes, arithmetic_tag> const & v,
                     simd_type <T, lanes, arithmetic_tag> const & u)
        noexcept
    {
        return simd::accumulate (v * u, T {0}, std::plus <T> {});
    }

    /*
     * Returns a SIMD vector of the real components of a complex SIMD vector.
     */
    template <typename T, std::size_t lanes>
    constexpr simd_type <T, lanes, arithmetic_tag>
        real (simd_type <T, lanes, complex_tag> const & v) noexcept
    {
        return simd_type <T, lanes, arithmetic_tag> {v.real ()};
    }

    /*
     * Returns a SIMD vector of the imaginary components of a complex SIMD
     * vector.
     */
    template <typename T, std::size_t lanes>
    constexpr simd_type <T, lanes, arithmetic_tag>
        imag (simd_type <T, lanes, complex_tag> const & v) noexcept
    {
        return simd_type <T, lanes, arithmetic_tag> {v.imag ()};
    }

    /*
     * Computes two SIMD vectors respectively containing the pairwise
     * quotient and remainder of integral division.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr std::pair <simd_type <T, lanes, arithmetic_tag>,
                         simd_type <T, lanes, arithmetic_tag>>
        div (simd_type <T, lanes, arithmetic_tag> const & v, T const & a) noexcept
    {
        using result_type = decltype (
            std::div (std::declval <T> (), std::declval <T> ())
        );

        std::array <result_type, lanes> results;
        for (std::size_t i = 0; i < lanes; ++i) {
            results [i] = std::div (v [i], a);
        }

        std::pair <simd_type <T, lanes, arithmetic_tag>,
                   simd_type <T, lanes, arithmetic_tag>>
            qr;

        for (std::size_t i = 0; i < lanes; ++i) {
            qr.first [i] = results [i].quot;
        }

        for (std::size_t i = 0; i < lanes; ++i) {
            qr.second [i] = results [i].rem;
        }

        return qr;
    }

    /*
     * Computes two SIMD vectors respectively containing the pairwise
     * quotient and remainder of integral division.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr std::pair <simd_type <T, lanes, arithmetic_tag>,
                         simd_type <T, lanes, arithmetic_tag>>
        div (simd_type <T, lanes, arithmetic_tag> const & u,
             simd_type <T, lanes, arithmetic_tag> const & v) noexcept
    {
        using result_type = decltype (
            std::div (std::declval <T> (), std::declval <T> ())
        );

        std::array <result_type, lanes> results;
        for (std::size_t i = 0; i < lanes; ++i) {
            results [i] = std::div (u [i], v [i]);
        }

        std::pair <simd_type <T, lanes, arithmetic_tag>,
                   simd_type <T, lanes, arithmetic_tag>>
            qr;

        for (std::size_t i = 0; i < lanes; ++i) {
            qr.first [i] = results [i].quot;
        }

        for (std::size_t i = 0; i < lanes; ++i) {
            qr.second [i] = results [i].rem;
        }

        return qr;
    }

    /*
     * Computes the absolute value for each lane of a SIMD vector.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <T, lanes, arithmetic_tag>
        abs (simd_type <T, lanes, arithmetic_tag> const & v) noexcept
    {
        return transform (std::abs <T>, v);
    }

    /*
     * Computes the absolute value for each lane of a complex SIMD vector
     * without undue underflow or overflow by calling std::hypot.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <T, lanes, arithmetic_tag>
        abs (simd_type <T, lanes, complex_tag> const & v) noexcept
    {
        return transform (
            [] (T const & a, T const & b) { return std::hypot (a, b); }, v
        );
    }

    /*
     * Computes the phase angle for each lane of a complex SIMD vector.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <T, lanes, arithmetic_tag>
        arg (simd_type <T, lanes, complex_tag> const & v) noexcept
    {
        return transform (std::arg <T>, v);
    }

    /*
     * Computes the norm for each lane of a complex SIMD vector.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <T, lanes, arithmetic_tag>
        norm (simd_type <T, lanes, complex_tag> const & v) noexcept
    {
        auto const & data = v.data ();
        auto const & reals = std::get <0> (data);
        auto const & imags = std::get <1> (data);

        return reals * reals + imags * imags;
    }

    /*
     * Computes the complex conjugate for each lane of a complex SIMD vector.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <T, lanes, complex_tag>
        conj (simd_type <T, lanes, complex_tag> const & v) noexcept
    {
        auto const & data = v.data ();
        auto const & reals = std::get <0> (data);
        auto const & imags = std::get <1> (data);

        return simd_type <T, lanes, complex_tag> (reals, -imags);
    }

    /*
     * Computes the projection onto the Riemann Sphere for each lane of a
     * complex SIMD vector.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <T, lanes, complex_tag>
        proj (simd_type <T, lanes, complex_tag> const & v) noexcept
    {
        return transform (std::proj <T>, v);
    }

    /*
     * Computes the exponential for each lane of a SIMD vector.
     */
    template <typename T, std::size_t lanes, typename tag>
    advanced_constexpr simd_type <T, lanes, tag>
        exp (simd_type <T, lanes, tag> const & v) noexcept
    {
        return transform (std::exp <T>, v);
    }

    /*
     * Computes the exponent base 2 for each lane of a SIMD vector.
     */
    template <typename T, std::size_t lanes, typename tag>
    advanced_constexpr simd_type <T, lanes, tag>
        exp2 (simd_type <T, lanes, tag> const & v) noexcept
    {
        return transform (std::exp2 <T>, v);
    }

    /*
     * Computes the exponential minus 1 for each lane of a SIMD vector.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <T, lanes, arithmetic_tag>
        expm1 (simd_type <T, lanes, arithmetic_tag> const & v) noexcept
    {
        return transform (std::expm1 <T>, v);
    }

    /*
     * Computes the natural logarithm for each lane of a SIMD vector.
     * For complex types branch cuts occur along the negative real axis.
     */
    template <typename T, std::size_t lanes, typename tag>
    advanced_constexpr simd_type <T, lanes, tag>
        log (simd_type <T, lanes, tag> const & v) noexcept
    {
        return transform (std::log <T>, v);
    }

    /*
     * Computes the logarithm base 10 for each lane of a SIMD vector.
     * For complex types branch cuts occur along the negative real axis.
     */
    template <typename T, std::size_t lanes, typename tag>
    advanced_constexpr simd_type <T, lanes, tag>
        log10 (simd_type <T, lanes, tag> const & v) noexcept
    {
        return transform (std::log10 <T>, v);
    }

    /*
     * Computes the logarithm base 2 for each lane of a SIMD vector.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <T, lanes, arithmetic_tag>
        log2 (simd_type <T, lanes, arithmetic_tag> const & v) noexcept
    {
        return transform (std::log2 <T>, v);
    }

    /*
     * Computes the natural logarithm for each lane of a SIMD vector
     * plus one.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <T, lanes, arithmetic_tag>
        log1p (simd_type <T, lanes, arithmetic_tag> const & v) noexcept
    {
        return transform (std::log1p <T>, v);
    }

    /*
     * Computes the square root for each lane of a SIMD vector.
     * For complex types the result lies in the right half-plane.
     */
    template <typename T, std::size_t lanes, typename tag>
    advanced_constexpr simd_type <T, lanes, tag>
        sqrt (simd_type <T, lanes, tag> const & v) noexcept
    {
        return transform (std::sqrt <T>, v);
    }

    /*
     * Computes the cube root for each lane of a SIMD vector.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <T, lanes, arithmetic_tag>
        cbrt (simd_type <T, lanes, arithmetic_tag> const & v) noexcept
    {
        return transform (std::cbrt <T>, v);
    }

    /*
     * Computes the hypotenuse (sqrt (x^2 + y^2)) for each pairwise lane of
     * SIMD vectors.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <T, lanes, arithmetic_tag>
        hypot (simd_type <T, lanes, arithmetic_tag> const & u,
               simd_type <T, lanes, arithmetic_tag> const & v) noexcept
    {
        using result_type = decltype (
            std::hypot (std::declval <T> (), std::declval <T> ())
        );

        simd_type <result_type, lanes, arithmetic_tag> result {};
        for (std::size_t i = 0; i < lanes; ++i) {
            result [i] = std::hypot (u [i], v [i]);
        }
        return result;
    }

    /*
     * Computes the power x^y for each lane, pairwise of two SIMD vectors.
     */
    template <typename T, std::size_t lanes, typename tag>
    advanced_constexpr simd_type <T, lanes, tag>
        pow (simd_type <T, lanes, tag> const & u,
             simd_type <T, lanes, tag> const & v) noexcept
    {
        simd_type <T, lanes, tag> result {};
        for (std::size_t i = 0; i < lanes; ++i) {
            result [i] = std::pow (u [i], v [i]);
        }
        return result;
    }

    /*
     * Computes the sine for each lane of a SIMD vector.
     */
    template <typename T, std::size_t lanes, typename tag>
    advanced_constexpr simd_type <T, lanes, tag>
        sin (simd_type <T, lanes, tag> const & v) noexcept
    {
        return transform (std::sin <T>, v);
    }

    /*
     * Computes the arcsine for each lane of a SIMD vector.
     */
    template <typename T, std::size_t lanes, typename tag>
    advanced_constexpr simd_type <T, lanes, tag>
        asin (simd_type <T, lanes, tag> const & v) noexcept
    {
        return transform (std::asin <T>, v);
    }

    /*
     * Computes the cosine for each lane of a SIMD vector.
     */
    template <typename T, std::size_t lanes, typename tag>
    advanced_constexpr simd_type <T, lanes, tag>
        cos (simd_type <T, lanes, tag> const & v) noexcept
    {
        return transform (std::cos <T>, v);
    }

    /*
     * Computes the arcosine for each lane of a SIMD vector.
     */
    template <typename T, std::size_t lanes, typename tag>
    advanced_constexpr simd_type <T, lanes, tag>
        acos (simd_type <T, lanes, tag> const & v) noexcept
    {
        return transform (std::acos <T>, v);
    }

    /*
     * Computes the tangent for each lane of a SIMD vector.
     */
    template <typename T, std::size_t lanes, typename tag>
    advanced_constexpr simd_type <T, lanes, tag>
        tan (simd_type <T, lanes, tag> const & v) noexcept
    {
        return transform (std::tan <T>, v);
    }

    /*
     * Computes the arctangent for each lane of a SIMD vector.
     */
    template <typename T, std::size_t lanes, typename tag>
    advanced_constexpr simd_type <T, lanes, tag>
        atan (simd_type <T, lanes, tag> const & v) noexcept
    {
        return transform (std::atan <T>, v);
    }

    /*
     * Computes the arctangent considering signs for each lane of a SIMD vector.
     */
    template <typename T, std::size_t lanes, typename tag>
    advanced_constexpr simd_type <T, lanes, arithmetic_tag>
        atan2 (simd_type <T, lanes, arithmetic_tag> const & v) noexcept
    {
        return transform (std::atan2 <T>, v);
    }

    /*
     * Computes the hyperbolic sine for each lane of a SIMD vector.
     */
    template <typename T, std::size_t lanes, typename tag>
    advanced_constexpr simd_type <T, lanes, tag>
        sinh (simd_type <T, lanes, tag> const & v) noexcept
    {
        return transform (std::sinh <T>, v);
    }

    /*
     * Computes the area hyperbolic sine for each lane of a SIMD vector.
     */
    template <typename T, std::size_t lanes, typename tag>
    advanced_constexpr simd_type <T, lanes, tag>
        asinh (simd_type <T, lanes, tag> const & v) noexcept
    {
        return transform (std::asinh <T>, v);
    }

    /*
     * Computes the hyperbolic cosine for each lane of a SIMD vector.
     */
    template <typename T, std::size_t lanes, typename tag>
    advanced_constexpr simd_type <T, lanes, tag>
        cosh (simd_type <T, lanes, tag> const & v) noexcept
    {
        return transform (std::cosh <T>, v);
    }

    /*
     * Computes the area hyperbolic cosine for each lane of a SIMD vector.
     */
    template <typename T, std::size_t lanes, typename tag>
    advanced_constexpr simd_type <T, lanes, tag>
        acosh (simd_type <T, lanes, tag> const & v) noexcept
    {
        return transform (std::acosh <T>, v);
    }

    /*
     * Computes the hyperbolic tangent for each lane of a SIMD vector.
     */
    template <typename T, std::size_t lanes, typename tag>
    advanced_constexpr simd_type <T, lanes, tag>
        tanh (simd_type <T, lanes, tag> const & v) noexcept
    {
        return transform (std::tanh <T>, v);
    }

    /*
     * Computes the area hyperbolic tangent for each lane of a SIMD vector.
     */
    template <typename T, std::size_t lanes, typename tag>
    advanced_constexpr simd_type <T, lanes, tag>
        atanh (simd_type <T, lanes, tag> const & v) noexcept
    {
        return transform (std::atanh <T>, v);
    }

    /*
     * Computes the error function for each lane of a SIMD vector.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <
        decltype (std::erf (std::declval <T> ())), lanes, arithmetic_tag
    >
        erf (simd_type <T, lanes, arithmetic_tag> const & v) noexcept
    {
        return transform (std::erf, v);
    }

    /*
     * Computes the complementary error function for each lane of a SIMD vector.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <
        decltype (std::erfc (std::declval <T> ())), lanes, arithmetic_tag
    >
        erfc (simd_type <T, lanes, arithmetic_tag> const & v) noexcept
    {
        return transform (std::erfc, v);
    }

    /*
     * Computes the gamma function for each lane of a SIMD vector.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <
        decltype (std::tgamma (std::declval <T> ())), lanes, arithmetic_tag
    >
        tgamma (simd_type <T, lanes, arithmetic_tag> const & v) noexcept
    {
        return transform (std::tgamma, v);
    }

    /*
     * Computes the natural logarithm of the gramma function for each lane of a
     * SIMD vector.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <
        decltype (std::lgamma (std::declval <T> ())), lanes, arithmetic_tag
    >
        lgamma (simd_type <T, lanes, arithmetic_tag> const & v) noexcept
    {
        return transform (std::lgamma, v);
    }

    /*
     * Computes the pairwise maximum of two SIMD vectors.
     */
    template <typename T, std::size_t lanes, typename tag>
    advanced_constexpr simd_type <T, lanes, tag>
        max (simd_type <T, lanes, tag> const & u,
             simd_type <T, lanes, tag> const & v) noexcept
    {
        simd_type <T, lanes, tag> result {};
        for (std::size_t i = 0; i < lanes; ++i) {
            result [i] = std::max (u [i], v [i]);
        }
        return result;
    }

    /*
     * Computes the pairwise minimum of two SIMD vectors.
     */
    template <typename T, std::size_t lanes, typename tag>
    advanced_constexpr simd_type <T, lanes, tag>
        min (simd_type <T, lanes, tag> const & u,
             simd_type <T, lanes, tag> const & v) noexcept
    {
        simd_type <T, lanes, tag> result {};
        for (std::size_t i = 0; i < lanes; ++i) {
            result [i] = std::min (u [i], v [i]);
        }
        return result;
    }

    /*
     * Computes the ceil for each lane of a SIMD vector.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <T, lanes, arithmetic_tag>
        ceil (simd_type <T, lanes, arithmetic_tag> const & v) noexcept
    {
        return transform ([] (T const & a) { return std::ceil (a); }, v);
    }

    /*
     * Computes the floor for each lane of a SIMD vector.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <T, lanes, arithmetic_tag>
        floor (simd_type <T, lanes, arithmetic_tag> const & v) noexcept
    {
        return transform ([] (T const & a) { return std::floor (a); }, v);
    }

    /*
     * Computes the truncation value for each lane of a SIMD vector.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <T, lanes, arithmetic_tag>
        trunc (simd_type <T, lanes, arithmetic_tag> const & v) noexcept
    {
        return transform ([] (T const & a) { return std::trunc (a); }, v);
    }

    /*
     * Computes the nearest integer value for each lane of a SIMD vector.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <T, lanes, arithmetic_tag>
        round (simd_type <T, lanes, arithmetic_tag> const & v) noexcept
    {
        return transform ([] (T const & a) { return std::round (a); }, v);
    }

    /*
     * Computes the nearest integer value for each lane of a SIMD vector using the
     * current rounding mode.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <T, lanes, arithmetic_tag>
        nearbyint (simd_type <T, lanes, arithmetic_tag> const & v) noexcept
    {
        return transform ([] (T const & a) { return std::nearbyint (a); }, v);
    }

    /*
     * Computes the decomposition of a number into significand and a power of 2,
     * returning a pair of SIMD vectors with the above values, respectively.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr std::pair <
        simd_type <decltype (
                    std::frexp (std::declval <T> (), std::declval <int *> ())
                   ), lanes, arithmetic_tag>,
        simd_type <int, lanes, arithmetic_tag>
    >
        frexp (simd_type <T, lanes, arithmetic_tag> const & v) noexcept
    {
        using result_type = decltype (
            std::frexp (std::declval <T> (), std::declval <int *> ())
        );

        std::pair <simd_type <result_type, lanes, arithmetic_tag>,
                   simd_type <int, lanes, arithmetic_tag>>
            result {};
        for (std::size_t i = 0; i < lanes; ++i) {
            result.first [i] = std::frexp (v [i], &result.second [i]);
        }
        return result;
    }

    /*
     * Computes a value times the number 2 raised to the exp power for each
     * lane of a SIMD vector. This overload uses the same exp for each
     * computation.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <
        typename std::common_type <
            T,
            decltype (std::ldexp (std::declval <T> (), std::declval <int> ()))
        >::type,
        lanes,
        arithmetic_tag
    >
        ldexp (simd_type <T, lanes, arithmetic_tag> const & v, int exp) noexcept
    {
        using result_type = decltype (
            std::ldexp (std::declval <T> (), std::declval <int> ())
        );
        using common_type = typename std::common_type <T, result_type>::type;
        using common_simd_type = simd_type <common_type, lanes, arithmetic_tag>;

        common_simd_type const exp2 {std::exp2 (exp)};
        return static_cast <common_simd_type> (v) * exp2;
    }

    /*
     * Computes a value times the number 2 raised to the exp power for each
     * lane of a SIMD vector. This overload uses a SIMD vector of
     * (potentially different) exponents for the computation.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <
        typename std::common_type <
            T,
            decltype (std::ldexp (std::declval <T> (), std::declval <int> ()))
        >::type,
        lanes,
        arithmetic_tag
    >
        ldexp (simd_type <T, lanes, arithmetic_tag> const & v,
               simd_type <int, lanes, arithmetic_tag> const & exp) noexcept
    {
        using common_type = simd_type <
            typename std::common_type <
                T,
                decltype (
                    std::ldexp (std::declval <T> (), std::declval <int> ())
                )
            >::type, lanes, arithmetic_tag
        >;

        auto const exp2 = transform (std::exp2, exp);
        return static_cast <common_type> (v) * exp2;
    }

    /*
     * Computes the decomposition of floating point values into integral and
     * fractional parts for each lane of a SIMD vector. Returns a pair
     * of SIMD vectors containing the integral and fractional parts,
     * respectively.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr std::pair <
        simd_type <T, lanes, arithmetic_tag>, simd_type <T, lanes, arithmetic_tag>
    >
        modf (simd_type <T, lanes, arithmetic_tag> const & v) noexcept
    {
        std::pair <
            simd_type <T, lanes, arithmetic_tag>, simd_type <T, lanes, arithmetic_tag>
        > result {};
        for (std::size_t i = 0; i < lanes; ++i) {
            result.first [i] = std::modf (v [i], &result.second [i]);
        }
        return result;
    }

    /*
     * Computes a value times the number FLT_RADIX raised to the exp power for
     * each lane of a SIMD vector. This overload uses the same exp for each
     * computation.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <
        typename std::common_type <
            T,
            decltype (std::scalbn (std::declval <T> (), std::declval <int> ()))
        >::type,
        lanes,
        arithmetic_tag
    >
        scalbn (simd_type <T, lanes, arithmetic_tag> const & v, int exp) noexcept
    {
        using result_type = decltype (
            std::scalbn (std::declval <T> (), std::declval <int> ())
        );
        using common_type = typename std::common_type <T, result_type>::type;
        using common_simd_type = simd_type <common_type, lanes, arithmetic_tag>;

        common_simd_type const exp_flt_radix {std::pow (FLT_RADIX, exp)};
        return static_cast <common_simd_type> (v) * exp_flt_radix;
    }

    /*
     * Computes a value times the number FLT_RADIX raised to the exp power for
     * each lane of a SIMD vector. This overload uses a SIMD vector of
     * (potentially different) exponents for the computation.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <
        typename std::common_type <
            T,
            decltype (std::scalbn (std::declval <T> (), std::declval <int> ()))
        >::type,
        lanes,
        arithmetic_tag
    >
        scalbn (simd_type <T, lanes, arithmetic_tag> const & v,
                simd_type <int, lanes, arithmetic_tag> const & exp) noexcept
    {
        using common_type = simd_type <
            typename std::common_type <
                T,
                decltype (
                    std::scalbn (std::declval <T> (), std::declval <int> ())
                )
            >::type, lanes, arithmetic_tag
        >;

        auto const exp_flt_radix = transform (
            [] (int e) { return std::pow (FLT_RADIX, e); }, exp
        );
        return static_cast <common_type> (v) * exp_flt_radix;
    }

    /*
     * Computes a value times the number FLT_RADIX raised to the long exp power
     * for each lane of a SIMD vector. This overload uses the same exp for
     * each computation.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <
        typename std::common_type <
            T,
            decltype (
                std::scalbln (std::declval <T> (), std::declval <long> ())
            )
        >::type,
        lanes,
        arithmetic_tag
    >
        scalbln (simd_type <T, lanes, arithmetic_tag> const & v, long exp) noexcept
    {
        using result_type = decltype (
            std::scalbln (std::declval <T> (), std::declval <long> ())
        );
        using common_type = typename std::common_type <T, result_type>::type;
        using common_simd_type = simd_type <common_type, lanes, arithmetic_tag>;

        common_simd_type const exp_flt_radix {std::pow (FLT_RADIX, exp)};
        return static_cast <common_simd_type> (v) * exp_flt_radix;
    }

    /*
     * Computes a value times the number FLT_RADIX raised to the exp power for
     * each lane of a SIMD vector. This overload uses a SIMD vector of
     * (potentially different) exponents for the computation.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <
        typename std::common_type <
            T,
            decltype (
                std::scalbln (std::declval <T> (), std::declval <long> ())
            )
        >::type,
        lanes,
        arithmetic_tag
    >
        scalbln (simd_type <T, lanes, arithmetic_tag> const & v,
                 simd_type <long, lanes, arithmetic_tag> const & exp) noexcept
    {
        using common_type = simd_type <
            typename std::common_type <
                T,
                decltype (
                    std::scalbln (std::declval <T> (), std::declval <long> ())
                )
            >::type, lanes, arithmetic_tag
        >;

        auto const exp_flt_radix = transform (
            [] (long e) { return std::pow (FLT_RADIX, e); }, exp
        );
        return static_cast <common_type> (v) * exp_flt_radix;
    }

    /*
     * Extracts the integral exponent of a floating point value for each lane
     * of a SIMD vector.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <int, lanes, arithmetic_tag>
        ilogb (simd_type <T, lanes, arithmetic_tag> const & v) noexcept
    {
        return transform (std::ilogb, v);
    }

    /*
     * Extracts the floating point radix independent exponent of a floating
     * point value, as a floating point result for each lane of a SIMD vector.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <
        decltype (std::logb (std::declval <T> ())), lanes, arithmetic_tag
    >
        logb (simd_type <T, lanes, arithmetic_tag> const & v) noexcept
    {
        return transform (std::ilogb, v);
    }

    /*
     * Computes the next representable value from the floating point value from
     * to the floating point value to for each lane of SIMD vectors.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <
        decltype (std::nextafter (std::declval <T> (), std::declval <T> ())),
        lanes, arithmetic_tag
    >
        nextafter (simd_type <T, lanes, arithmetic_tag> const & from,
                   simd_type <T, lanes, arithmetic_tag> const & to) noexcept
    {
        simd_type <
            decltype (
                std::nextafter (std::declval <T> (), std::declval <T> ())
            ),
            lanes, arithmetic_tag
        > result {};
        for (std::size_t i = 0; i < lanes; ++i) {
            result [i] = std::nextafter (from [i], to [i]);
        }
        return result;
    }

    /*
     * Computes the next representable value from the floating point value from
     * to the floating point value to for each lane of SIMD vectors.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <
        decltype (std::nextafter (std::declval <T> (), std::declval <T> ())),
        lanes, arithmetic_tag
    >
        nexttoward (simd_type <T, lanes, arithmetic_tag> const & from,
                    simd_type <T, lanes, arithmetic_tag> const & to) noexcept
    {
        simd_type <
            decltype (
                std::nextafter (std::declval <T> (), std::declval <T> ())
            ),
            lanes, arithmetic_tag
        > result {};
        for (std::size_t i = 0; i < lanes; ++i) {
            result [i] = std::nexttoward (from [i], to [i]);
        }
        return result;
    }

    /*
     * Computes a floating point value with the magnitude of the first floating
     * point value and the sign of the second floating point value for each lane
     * of SIMD vectors.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <
        decltype (std::nextafter (std::declval <T> (), std::declval <T> ())),
        lanes, arithmetic_tag
    >
        copysign (simd_type <T, lanes, arithmetic_tag> const & mag,
                  simd_type <T, lanes, arithmetic_tag> const & sgn) noexcept
    {
        simd_type <
            decltype (
                std::nextafter (std::declval <T> (), std::declval <T> ())
            ),
            lanes, arithmetic_tag
        > result {};
        for (std::size_t i = 0; i < lanes; ++i) {
            result [i] = std::copysign (mag [i], sgn [i]);
        }
        return result;
    }

    /*
     * Classifies the floating point value into one of: zero, subnormal, normal,
     * infinite, NaN, or an implementation defined category for each lane of a
     * SIMD vector.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <int, lanes, arithmetic_tag>
        fpclassify (simd_type <T, lanes, arithmetic_tag> const & v) noexcept
    {
        return transform (std::fpclassify, v);
    }

    /*
     * Determines if a floating point value is finite for each lane of a SIMD
     * vector.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <detail::integral_type_switch <T>, lanes, boolean_tag>
        isfinite (simd_type <T, lanes, arithmetic_tag> const & v) noexcept
    {
        constexpr simd_type <T, lanes, arithmetic_tag> pinf {+INFINITY};
        constexpr simd_type <T, lanes, arithmetic_tag> ninf {-INFINITY};

        return (v == v) && (v != pinf) && (v != ninf);
    }

    /*
     * Determines if a floating point value is infinite for each lane of a SIMD
     * vector.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <detail::integral_type_switch <T>, lanes, boolean_tag>
        isinf (simd_type <T, lanes, arithmetic_tag> const & v) noexcept
    {
        constexpr simd_type <T, lanes, arithmetic_tag> pinf {+INFINITY};
        constexpr simd_type <T, lanes, arithmetic_tag> ninf {-INFINITY};

        return (v == pinf) || (v == ninf);
    }

    /*
     * Determines if a floating point value is not-a-number for each lane of a
     * SIMD vector.
     */
    template <typename T, std::size_t lanes>
    constexpr simd_type <detail::integral_type_switch <T>, lanes, boolean_tag>
        isnan (simd_type <T, lanes, arithmetic_tag> const & v) noexcept
    {
        return v != v;
    }

    /*
     * Determines if a floating point value is normal (neither zero, subnormal,
     * infinite, nor NaN) for each lane of a SIMD vector.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <detail::integral_type_switch <T>, lanes, boolean_tag>
        isnormal (simd_type <T, lanes, arithmetic_tag> const & v) noexcept
    {
        return transform (std::isnormal, v);
    }

    /*
     * Determines if a floating point value is negative for each lane of a SIMD
     * vector.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <detail::integral_type_switch <T>, lanes, boolean_tag>
        signbit (simd_type <T, lanes, arithmetic_tag> const & v) noexcept
    {
        return transform (std::signbit, v);
    }

    /*
     * Determines the result of whether a floating point value is greater than
     * another floating point value for each lane of a SIMD vector.  This
     * function does not set floating point exceptions. This overload uses the
     * same value for comparison across all lanes of the first argument.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <detail::integral_type_switch <T>, lanes, boolean_tag>
        isgreater (simd_type <T, lanes, arithmetic_tag> const & v, T const & cmp)
        noexcept
    {
        simd_type <detail::integral_type_switch <T>, lanes, boolean_tag> result {};
        for (std::size_t i = 0; i < lanes; ++i) {
            result [i] = std::isgreater (v [i], cmp);
        }
        return result;
    }

    /*
     * Determines the pairwise result of whether a floating point value is
     * greater than another floating point value for each lane of SIMD vectors.
     * This function does not set floating point exceptions.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <detail::integral_type_switch <T>, lanes, boolean_tag>
        isgreater (simd_type <T, lanes, arithmetic_tag> const & u,
                   simd_type <T, lanes, arithmetic_tag> const & v)
        noexcept
    {
        simd_type <detail::integral_type_switch <T>, lanes, boolean_tag> result {};
        for (std::size_t i = 0; i < lanes; ++i) {
            result [i] = std::isgreater (u [i], v [i]);
        }
        return result;
    }

    /*
     * Determines the result of whether a floating point value is greater than
     * or equal to another floating point value for each lane of a SIMD vector.
     * This function does not set floating point exceptions. This overload uses
     * the same value for comparison across all lanes of the first argument.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <detail::integral_type_switch <T>, lanes, boolean_tag>
        isgreaterequal (simd_type <T, lanes, arithmetic_tag> const & v, T const & cmp)
        noexcept
    {
        simd_type <detail::integral_type_switch <T>, lanes, boolean_tag> result {};
        for (std::size_t i = 0; i < lanes; ++i) {
            result [i] = std::isgreaterequal (v [i], cmp);
        }
        return result;
    }

    /*
     * Determines the pairwise result of whether a floating point value is
     * greater than or equal to another floating point value for each lane of
     * SIMD vectors. This function does not set floating point exceptions.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <detail::integral_type_switch <T>, lanes, boolean_tag>
        isgreaterequal (simd_type <T, lanes, arithmetic_tag> const & u,
                        simd_type <T, lanes, arithmetic_tag> const & v)
        noexcept
    {
        simd_type <detail::integral_type_switch <T>, lanes, boolean_tag> result {};
        for (std::size_t i = 0; i < lanes; ++i) {
            result [i] = std::isgreaterequal (u [i], v [i]);
        }
        return result;
    }

    /*
     * Determines the result of whether a floating point value is less than
     * another floating point value for each lane of a SIMD vector.  This
     * function does not set floating point exceptions. This overload uses the
     * same value for comparison across all lanes of the first argument.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <detail::integral_type_switch <T>, lanes, boolean_tag>
        isless (simd_type <T, lanes, arithmetic_tag> const & v, T const & cmp)
        noexcept
    {
        simd_type <detail::integral_type_switch <T>, lanes, boolean_tag> result {};
        for (std::size_t i = 0; i < lanes; ++i) {
            result [i] = std::isless (v [i], cmp);
        }
        return result;
    }

    /*
     * Determines the pairwise result of whether a floating point value is
     * less than another floating point value for each lane of SIMD vectors.
     * This function does not set floating point exceptions.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <detail::integral_type_switch <T>, lanes, boolean_tag>
        isless (simd_type <T, lanes, arithmetic_tag> const & u,
                simd_type <T, lanes, arithmetic_tag> const & v)
        noexcept
    {
        simd_type <detail::integral_type_switch <T>, lanes, boolean_tag> result {};
        for (std::size_t i = 0; i < lanes; ++i) {
            result [i] = std::isless (u [i], v [i]);
        }
        return result;
    }

    /*
     * Determines the result of whether a floating point value is less than
     * or equal to another floating point value for each lane of a SIMD vector.
     * This function does not set floating point exceptions. This overload uses
     * the same value for comparison across all lanes of the first argument.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <detail::integral_type_switch <T>, lanes, boolean_tag>
        islessequal (simd_type <T, lanes, arithmetic_tag> const & v, T const & cmp)
        noexcept
    {
        simd_type <detail::integral_type_switch <T>, lanes, boolean_tag> result {};
        for (std::size_t i = 0; i < lanes; ++i) {
            result [i] = std::islessequal (v [i], cmp);
        }
        return result;
    }

    /*
     * Determines the pairwise result of whether a floating point value is
     * less than or equal to another floating point value for each lane of
     * SIMD vectors. This function does not set floating point exceptions.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <detail::integral_type_switch <T>, lanes, boolean_tag>
        islessequal (simd_type <T, lanes, arithmetic_tag> const & u,
                     simd_type <T, lanes, arithmetic_tag> const & v)
        noexcept
    {
        simd_type <detail::integral_type_switch <T>, lanes, boolean_tag> result {};
        for (std::size_t i = 0; i < lanes; ++i) {
            result [i] = std::islessequal (u [i], v [i]);
        }
        return result;
    }

    /*
     * Determines the result of whether a floating point value is less than
     * or greater than another floating point value for each lane of a SIMD
     * vector. This function does not set floating point exceptions. This
     * overload uses the same value for comparison across all lanes of the first
     * argument.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <detail::integral_type_switch <T>, lanes, boolean_tag>
        islessgreater (simd_type <T, lanes, arithmetic_tag> const & v, T const & cmp)
        noexcept
    {
        simd_type <detail::integral_type_switch <T>, lanes, boolean_tag> result {};
        for (std::size_t i = 0; i < lanes; ++i) {
            result [i] = std::islessgreater (v [i], cmp);
        }
        return result;
    }

    /*
     * Determines the pairwise result of whether a floating point value is
     * less than or greater than another floating point value for each lane of
     * SIMD vectors. This function does not set floating point exceptions.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <detail::integral_type_switch <T>, lanes, boolean_tag>
        islessgreater (simd_type <T, lanes, arithmetic_tag> const & u,
                       simd_type <T, lanes, arithmetic_tag> const & v)
        noexcept
    {
        simd_type <detail::integral_type_switch <T>, lanes, boolean_tag> result {};
        for (std::size_t i = 0; i < lanes; ++i) {
            result [i] = std::islessgreater (u [i], v [i]);
        }
        return result;
    }

    /*
     * Determines the result of whether a floating point value is unordered
     * with another floating point value for each lane of a SIMD  vector. This
     * function does not set floating point exceptions. This overload uses the
     * same value for comparison across all lanes of the first argument.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <detail::integral_type_switch <T>, lanes, boolean_tag>
        isunordered (simd_type <T, lanes, arithmetic_tag> const & v, T const & cmp)
        noexcept
    {
        simd_type <detail::integral_type_switch <T>, lanes, boolean_tag> result {};
        for (std::size_t i = 0; i < lanes; ++i) {
            result [i] = std::isunordered (v [i], cmp);
        }
        return result;
    }

    /*
     * Determines the pairwise result of whether a floating point value is
     * unordered with another floating point value for each lane of SIMD
     * vectors. This function does not set floating point exceptions.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <detail::integral_type_switch <T>, lanes, boolean_tag>
        isunordered (simd_type <T, lanes, arithmetic_tag> const & u,
                       simd_type <T, lanes, arithmetic_tag> const & v)
        noexcept
    {
        simd_type <detail::integral_type_switch <T>, lanes, boolean_tag> result {};
        for (std::size_t i = 0; i < lanes; ++i) {
            result [i] = std::isunordered (u [i], v [i]);
        }
        return result;
    }

    /*
     * Computes the pairwise fmod of two SIMD vectors.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <T, lanes, arithmetic_tag>
        fmod (simd_type <T, lanes, arithmetic_tag> const & u,
              simd_type <T, lanes, arithmetic_tag> const & v) noexcept
    {
        using result_type = decltype (
            std::fmod (std::declval <T> (), std::declval <T> ())
        );

        simd_type <result_type, lanes, arithmetic_tag> result {};
        for (std::size_t i = 0; i < lanes; ++i) {
            result [i] = std::fmod (u [i], v [i]);
        }
        return result;
    }

    /*
     * Computes the pairwise remainder of two SIMD vectors.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <T, lanes, arithmetic_tag>
        remainder (simd_type <T, lanes, arithmetic_tag> const & u,
                   simd_type <T, lanes, arithmetic_tag> const & v) noexcept
    {
        using result_type = decltype (
            std::remainder (std::declval <T> (), std::declval <T> ())
        );

        simd_type <result_type, lanes, arithmetic_tag> result {};
        for (std::size_t i = 0; i < lanes; ++i) {
            result [i] = std::remainder (u [i], v [i]);
        }
        return result;
    }

    /*
     * Computes the fused multiply and add operation of three SIMD vectors,
     * in the form (u * v) + w.
     */
    template <typename T, std::size_t lanes>
    advanced_constexpr simd_type <T, lanes, arithmetic_tag>
        fma (simd_type <T, lanes, arithmetic_tag> const & u,
             simd_type <T, lanes, arithmetic_tag> const & v,
             simd_type <T, lanes, arithmetic_tag> const & w) noexcept
    {
        using result_type = decltype (
            std::fma (
                std::declval <T> (), std::declval <T> (), std::declval <T> ()
            )
        );

        simd_type <result_type, lanes, arithmetic_tag> result {};
        for (std::size_t i = 0; i < lanes; ++i) {
            result [i] = std::fma (u [i], v [i], w [i]);
        }
        return result;
    }

#if __cplusplus > 201402L
    /*
     * Computes the pairwise gcd of two SIMD vectors.
     */
    template <typename T, std::size_t lanes>
    constexpr simd_type <T, lanes, arithmetic_tag>
        gcd (simd_type <T, lanes, arithmetic_tag> const & u,
             simd_type <T, lanes, arithmetic_tag> const & v) noexcept
    {
        static_assert (
            std::is_integral <T>::value,
            "template parameter type T must be an integral type"
        );

        simd_type <T, lanes, arithmetic_tag> result {};
        for (std::size_t i = 0; i < lanes; ++i) {
            result [i] = std::gcd (u [i], v [i]);
        }
        return result;
    }

    /*
     * Computes the pairwise lcm of two SIMD vectors.
     */
    template <typename T, std::size_t lanes>
    constexpr simd_type <T, lanes, arithmetic_tag>
        lcm (simd_type <T, lanes, arithmetic_tag> const & u,
             simd_type <T, lanes, arithmetic_tag> const & v) noexcept
    {
        static_assert (
            std::is_integral <T>::value,
            "template parameter type T must be an integral type"
        );

        simd_type <T, lanes, arithmetic_tag> result {};
        for (std::size_t i = 0; i < lanes; ++i) {
            result [i] = std::lcm (u [i], v [i]);
        }
        return result;
    }

    /*
     * Computes the clamped value for each lane of a SIMD vector.
     */
    template <typename T, std::size_t lanes, typename tag>
    constexpr simd_type <T, lanes, tag>
        clamp (simd_type <T, lanes, tag> const & v, T const & lo, T const & hi)
        noexcept
    {
        return transform (
            [&lo, &hi] (T const & a) { return std::clamp (a, lo, hi); }, v
        );
    }
#endif

    /*
     * These are the default provided typedefs for SIMD vector types, they cover
     * the normal range of vector types available on targets with 64 bit,
     * 128 bit, 256 bit, and/or 512 bit support. Clang and GCC will synthesize
     * instructions when target hardware support is not available, so we
     * provide all common SIMD vector types. Target specific typedefs are
     * provided below.
     */
inline namespace common
{
    /* 8 8-bit lanes */
    using bool8x8_t = simd_type <std::int8_t, 8, simd::boolean_tag>;
    using int8x8_t  = simd_type <std::int8_t, 8>;
    using uint8x8_t = simd_type <std::uint8_t, 8>;

    /* 16 8-bit lanes */
    using bool8x16_t = simd_type <std::int8_t, 16, simd::boolean_tag>;
    using int8x16_t  = simd_type <std::int8_t, 16>;
    using uint8x16_t = simd_type <std::uint8_t, 16>;

    /* 32 8-bit lanes */
    using bool8x32_t = simd_type <std::int8_t, 32, simd::boolean_tag>;
    using int8x32_t  = simd_type <std::int8_t, 32>;
    using uint8x32_t = simd_type <std::uint8_t, 32>;

    /* 64 8-bit lanes */
    using bool8x64_t = simd_type <std::int8_t, 64, simd::boolean_tag>;
    using int8x64_t  = simd_type <std::int8_t, 64>;
    using uint8x64_t = simd_type <std::uint8_t, 64>;

    /* 4 16-bit lanes */
    using bool16x4_t = simd_type <std::int16_t, 4, simd::boolean_tag>;
    using int16x4_t  = simd_type <std::int16_t, 4>;
    using uint16x4_t = simd_type <std::uint16_t, 4>;

    /* 8 16-bit lanes */
    using bool16x8_t = simd_type <std::int16_t, 8, simd::boolean_tag>;
    using int16x8_t  = simd_type <std::int16_t, 8>;
    using uint16x8_t = simd_type <std::uint16_t, 8>;

    /* 16 16-bit lanes */
    using bool16x16_t = simd_type <std::int16_t, 16, simd::boolean_tag>;
    using int16x16_t  = simd_type <std::int16_t, 16>;
    using uint16x16_t = simd_type <std::uint16_t, 16>;

    /* 32 16-bit lanes */
    using bool16x32_t = simd_type <std::int16_t, 32, simd::boolean_tag>;
    using int16x32_t  = simd_type <std::int16_t, 32>;
    using uint16x32_t = simd_type <std::uint16_t, 32>;

    /* 2 32-bit lanes */
    using bool32x2_t  = simd_type <std::int32_t, 2, simd::boolean_tag>;
    using int32x2_t   = simd_type <std::int32_t, 2>;
    using uint32x2_t  = simd_type <std::uint32_t, 2>;
    using float32x2_t = simd_type <float, 2>;
    using complex_float32x2_t = simd_type <float, 2, simd::complex_tag>;

    /* 4 32-bit lanes */
    using bool32x4_t  = simd_type <std::int32_t, 4, simd::boolean_tag>;
    using int32x4_t   = simd_type <std::int32_t, 4>;
    using uint32x4_t  = simd_type <std::uint32_t, 4>;
    using float32x4_t = simd_type <float, 4>;
    using complex_float32x4_t = simd_type <float, 4, simd::complex_tag>;

    /* 8 32-bit lanes */
    using bool32x8_t  = simd_type <std::int32_t, 8, simd::boolean_tag>;
    using int32x8_t   = simd_type <std::int32_t, 8>;
    using uint32x8_t  = simd_type <std::uint32_t, 8>;
    using float32x8_t = simd_type <float, 8>;
    using complex_float32x8_t = simd_type <float, 8, simd::complex_tag>;

    /* 16 32-bit lanes */
    using bool32x16_t  = simd_type <std::int32_t, 16, simd::boolean_tag>;
    using int32x16_t   = simd_type <std::int32_t, 16>;
    using uint32x16_t  = simd_type <std::uint32_t, 16>;
    using float32x16_t = simd_type <float, 16>;
    using complex_float32x16_t = simd_type <float, 16, simd::complex_tag>;

    /* 1 64-bit lane */
    using bool64x1_t  = simd_type <std::int64_t, 1, simd::boolean_tag>;
    using int64x1_t   = simd_type <std::int64_t, 1>;
    using uint64x1_t  = simd_type <std::uint64_t, 1>;
    using float64x1_t = simd_type <double, 1>;
    using complex_float64x1_t = simd_type <double, 1, simd::complex_tag>;

    /* 2 64-bit lanes */
    using bool64x2_t  = simd_type <std::int64_t, 2, simd::boolean_tag>;
    using int64x2_t   = simd_type <std::int64_t, 2>;
    using uint64x2_t  = simd_type <std::uint64_t, 2>;
    using float64x2_t = simd_type <double, 2>;
    using complex_float64x2_t = simd_type <double, 2, simd::complex_tag>;

    /* 4 64-bit lanes */
    using bool64x4_t  = simd_type <std::int64_t, 4, simd::boolean_tag>;
    using int64x4_t   = simd_type <std::int64_t, 4>;
    using uint64x4_t  = simd_type <std::uint64_t, 4>;
    using float64x4_t = simd_type <double, 4>;
    using complex_float64x4_t = simd_type <double, 4, simd::complex_tag>;

    /* 8 64-bit lanes */
    using bool64x8_t  = simd_type <std::int64_t, 8, simd::boolean_tag>;
    using int64x8_t   = simd_type <std::int64_t, 8>;
    using uint64x8_t  = simd_type <std::uint64_t, 8>;
    using float64x8_t = simd_type <double, 8>;
    using complex_float64x8_t = simd_type <float, 8, simd::complex_tag>;

    /*
     * long double specializations; may be 80-bit (x87), 128-bit,
     * or even a synonym for double floating point types depending
     * on the implementation.
     */

    /* long double x 2 */
    using long_doublex2_t = simd_type <long double, 2>;
    using complex_long_doublex2_t =
        simd_type <long double, 2, simd::complex_tag>;

    /* long double x 4 */
    using long_doublex4_t = simd_type <long double, 4>;
    using complex_long_doublex4_t =
        simd_type <long double, 4, simd::complex_tag>;

    /* Guaranteed 128-bit integer SIMD vectors */
    /* 1 128-bit lane */
#if defined (__clang__)
    using bool128x1_t = simd_type <__int128_t, 1, simd::boolean_tag>;
    using int128x1_t  = simd_type <__int128_t, 1>;
    using uint128x1_t = simd_type <__uint128_t, 1>;
#elif defined (__GNUG__)
    using bool128x1_t = simd_type <__int128, 1, simd::boolean_tag>;
    using int128x1_t  = simd_type <__int128, 1>;
    using uint128x1_t = simd_type <unsigned __int128, 1>;
#endif

    /* 2 128-bit lanes */
#if defined (__clang__)
    using bool128x2_t = simd_type <__int128_t, 2, simd::boolean_tag>;
    using int128x2_t  = simd_type <__int128_t, 2>;
    using uint128x2_t = simd_type <__uint128_t, 2>;
#elif defined (__GNUG__)
    using bool128x2_t = simd_type <__int128, 2, simd::boolean_tag>;
    using int128x2_t  = simd_type <__int128, 2>;
    using uint128x2_t = simd_type <unsigned __int128, 2>;
#endif

    /* 4 128-bit lanes */
#if defined (__clang__)
    using bool128x4_t = simd_type <__int128_t, 4, simd::boolean_tag>;
    using int128x4_t  = simd_type <__int128_t, 4>;
    using uint128x4_t = simd_type <__uint128_t, 4>;
#elif defined (__GNUG__)
    using bool128x4_t = simd_type <__int128, 4, simd::boolean_tag>;
    using int128x4_t  = simd_type <__int128, 4>;
    using uint128x4_t = simd_type <unsigned __int128, 4>;
#endif
}   // inline namespace common

    /*
     * These are target technology specific typedefs for SIMD vector types, for
     * when it is undesirable to allow Clang or GCC to synthesize instructions
     * for the target archetecture.
     *
     * Please note that for any given target technology Clang and GCC
     * may still have to synthesize instructions if operations that are
     * not backed by hardware support are used. It is up to the end-user
     * to ensure that the used operations have hardware support.
     */
namespace mmx
{
    /* mmx registers (64-bit) */
    /* 8 8-bit lanes */
    using bool8x8_t = simd_type <std::int8_t, 8, simd::boolean_tag>;
    using int8x8_t  = simd_type <std::int8_t, 8>;
    using uint8x8_t = simd_type <std::uint8_t, 8>;

    /* 4 16-bit lanes */
    using bool16x4_t = simd_type <std::int16_t, 4, simd::boolean_tag>;
    using int16x4_t  = simd_type <std::int16_t, 4>;
    using uint16x4_t = simd_type <std::uint16_t, 4>;

    /* 2 32-bit lanes */
    using bool32x2_t  = simd_type <std::int32_t, 2, simd::boolean_tag>;
    using int32x2_t   = simd_type <std::int32_t, 2>;
    using uint32x2_t  = simd_type <std::uint32_t, 2>;

    /* 1 64-bit lane */
    using bool64x1_t  = simd_type <std::int64_t, 1, simd::boolean_tag>;
    using int64x1_t   = simd_type <std::int64_t, 1>;
    using uint64x1_t  = simd_type <std::uint64_t, 1>;
}   // namespace mmx

namespace sse
{
    /* mmx registers (64-bit) */
    /* 8 8-bit lanes */
    using bool8x8_t = simd_type <std::int8_t, 8, simd::boolean_tag>;
    using int8x8_t  = simd_type <std::int8_t, 8>;
    using uint8x8_t = simd_type <std::uint8_t, 8>;

    /* 4 16-bit lanes */
    using bool16x4_t = simd_type <std::int16_t, 4, simd::boolean_tag>;
    using int16x4_t  = simd_type <std::int16_t, 4>;
    using uint16x4_t = simd_type <std::uint16_t, 4>;

    /* 2 32-bit lanes */
    using bool32x2_t  = simd_type <std::int32_t, 2, simd::boolean_tag>;
    using int32x2_t   = simd_type <std::int32_t, 2>;
    using uint32x2_t  = simd_type <std::uint32_t, 2>;

    /* 1 64-bit lane */
    using bool64x1_t  = simd_type <std::int64_t, 1, simd::boolean_tag>;
    using int64x1_t   = simd_type <std::int64_t, 1>;
    using uint64x1_t  = simd_type <std::uint64_t, 1>;

    /* xmm registers (128-bit) */
    /* 4 32 bit lanes */
    using float32x4_t = simd_type <float, 4>;
    using complex_float32x4_t = simd_type <float, 4, simd::complex_tag>;
}   // namespace sse

namespace sse2
{
    /* mmx registers (64-bit) */
    /* 8 8-bit lanes */
    using bool8x8_t = simd_type <std::int8_t, 8, simd::boolean_tag>;
    using int8x8_t  = simd_type <std::int8_t, 8>;
    using uint8x8_t = simd_type <std::uint8_t, 8>;

    /* 4 16-bit lanes */
    using bool16x4_t = simd_type <std::int16_t, 4, simd::boolean_tag>;
    using int16x4_t  = simd_type <std::int16_t, 4>;
    using uint16x4_t = simd_type <std::uint16_t, 4>;

    /* 2 32-bit lanes */
    using bool32x2_t  = simd_type <std::int32_t, 2, simd::boolean_tag>;
    using int32x2_t   = simd_type <std::int32_t, 2>;
    using uint32x2_t  = simd_type <std::uint32_t, 2>;

    /* 1 64-bit lane */
    using bool64x1_t  = simd_type <std::int64_t, 1, simd::boolean_tag>;
    using int64x1_t   = simd_type <std::int64_t, 1>;
    using uint64x1_t  = simd_type <std::uint64_t, 1>;

    /* xmm registers (128-bit) */
    /* 16 8-bit lanes */
    using bool8x16_t = simd_type <std::int8_t, 16, simd::boolean_tag>;
    using int8x16_t  = simd_type <std::int8_t, 16>;
    using uint8x16_t = simd_type <std::uint8_t, 16>;

    /* 8 16-bit lanes */
    using bool16x8_t = simd_type <std::int16_t, 8, simd::boolean_tag>;
    using int16x8_t  = simd_type <std::int16_t, 8>;
    using uint16x8_t = simd_type <std::uint16_t, 8>;

    /* 4 32-bit lanes */
    using bool32x4_t  = simd_type <std::int32_t, 4, simd::boolean_tag>;
    using int32x4_t   = simd_type <std::int32_t, 4>;
    using uint32x4_t  = simd_type <std::uint32_t, 4>;
    using float32x4_t = simd_type <float, 4>;
    using complex_float32x4_t = simd_type <float, 4, simd::complex_tag>;

    /* 2 64-bit lanes */
    using bool64x2_t  = simd_type <std::int64_t, 2, simd::boolean_tag>;
    using int64x2_t   = simd_type <std::int64_t, 2>;
    using uint64x2_t  = simd_type <std::uint64_t, 2>;
    using float64x2_t = simd_type <double, 2>;
    using complex_float64x2_t = simd_type <double, 2, simd::complex_tag>;

    /* 1 128-bit lane (x86 doublequadword) */
#if defined (__clang__)
    using bool128x1_t = simd_type <__int128_t, 1, simd::boolean_tag>;
    using int128x1_t  = simd_type <__int128_t, 1>;
    using uint128x1_t = simd_type <__uint128_t, 1>;
#elif defined (__GNUG__)
    using bool128x1_t = simd_type <__int128, 1, simd::boolean_tag>;
    using int128x1_t  = simd_type <__int128, 1>;
    using uint128x1_t = simd_type <unsigned __int128, 1>;
#endif
}   // namespace sse2

/*
 * Available types in SSE3/4.1/4.2 and SSE4a (AMD) are the same as those
 * availalbe in SSE2 since no new registers beyond the MMX and XMM registers
 * were introduced (256 bit registers were not available until the AVX
 * extensions).
 */
namespace sse3
{
    /* mmx registers (64-bit) */
    /* 8 8-bit lanes */
    using bool8x8_t = simd_type <std::int8_t, 8, simd::boolean_tag>;
    using int8x8_t  = simd_type <std::int8_t, 8>;
    using uint8x8_t = simd_type <std::uint8_t, 8>;

    /* 4 16-bit lanes */
    using bool16x4_t = simd_type <std::int16_t, 4, simd::boolean_tag>;
    using int16x4_t  = simd_type <std::int16_t, 4>;
    using uint16x4_t = simd_type <std::uint16_t, 4>;

    /* 2 32-bit lanes */
    using bool32x2_t  = simd_type <std::int32_t, 2, simd::boolean_tag>;
    using int32x2_t   = simd_type <std::int32_t, 2>;
    using uint32x2_t  = simd_type <std::uint32_t, 2>;

    /* 1 64-bit lane */
    using bool64x1_t  = simd_type <std::int64_t, 1, simd::boolean_tag>;
    using int64x1_t   = simd_type <std::int64_t, 1>;
    using uint64x1_t  = simd_type <std::uint64_t, 1>;

    /* xmm registers (128-bit) */
    /* 16 8-bit lanes */
    using bool8x16_t = simd_type <std::int8_t, 16, simd::boolean_tag>;
    using int8x16_t  = simd_type <std::int8_t, 16>;
    using uint8x16_t = simd_type <std::uint8_t, 16>;

    /* 8 16-bit lanes */
    using bool16x8_t = simd_type <std::int16_t, 8, simd::boolean_tag>;
    using int16x8_t  = simd_type <std::int16_t, 8>;
    using uint16x8_t = simd_type <std::uint16_t, 8>;

    /* 4 32-bit lanes */
    using bool32x4_t  = simd_type <std::int32_t, 4, simd::boolean_tag>;
    using int32x4_t   = simd_type <std::int32_t, 4>;
    using uint32x4_t  = simd_type <std::uint32_t, 4>;
    using float32x4_t = simd_type <float, 4>;
    using complex_float32x4_t = simd_type <float, 4, simd::complex_tag>;

    /* 2 64-bit lanes */
    using bool64x2_t  = simd_type <std::int64_t, 2, simd::boolean_tag>;
    using int64x2_t   = simd_type <std::int64_t, 2>;
    using uint64x2_t  = simd_type <std::uint64_t, 2>;
    using float64x2_t = simd_type <double, 2>;
    using complex_float64x2_t = simd_type <double, 2, simd::complex_tag>;

    /* 1 128-bit lane (x86 doublequadword) */
#if defined (__clang__)
    using bool128x1_t = simd_type <__int128_t, 1, simd::boolean_tag>;
    using int128x1_t  = simd_type <__int128_t, 1>;
    using uint128x1_t = simd_type <__uint128_t, 1>;
#elif defined (__GNUG__)
    using bool128x1_t = simd_type <__int128, 1, simd::boolean_tag>;
    using int128x1_t  = simd_type <__int128, 1>;
    using uint128x1_t = simd_type <unsigned __int128, 1>;
#endif
}   // namespace sse3

namespace ssse3
{
    /* mmx registers (64-bit) */
    /* 8 8-bit lanes */
    using bool8x8_t = simd_type <std::int8_t, 8, simd::boolean_tag>;
    using int8x8_t  = simd_type <std::int8_t, 8>;
    using uint8x8_t = simd_type <std::uint8_t, 8>;

    /* 4 16-bit lanes */
    using bool16x4_t = simd_type <std::int16_t, 4, simd::boolean_tag>;
    using int16x4_t  = simd_type <std::int16_t, 4>;
    using uint16x4_t = simd_type <std::uint16_t, 4>;

    /* 2 32-bit lanes */
    using bool32x2_t  = simd_type <std::int32_t, 2, simd::boolean_tag>;
    using int32x2_t   = simd_type <std::int32_t, 2>;
    using uint32x2_t  = simd_type <std::uint32_t, 2>;

    /* 1 64-bit lane */
    using bool64x1_t  = simd_type <std::int64_t, 1, simd::boolean_tag>;
    using int64x1_t   = simd_type <std::int64_t, 1>;
    using uint64x1_t  = simd_type <std::uint64_t, 1>;

    /* xmm registers (128-bit) */
    /* 16 8-bit lanes */
    using bool8x16_t = simd_type <std::int8_t, 16, simd::boolean_tag>;
    using int8x16_t  = simd_type <std::int8_t, 16>;
    using uint8x16_t = simd_type <std::uint8_t, 16>;

    /* 8 16-bit lanes */
    using bool16x8_t = simd_type <std::int16_t, 8, simd::boolean_tag>;
    using int16x8_t  = simd_type <std::int16_t, 8>;
    using uint16x8_t = simd_type <std::uint16_t, 8>;

    /* 4 32-bit lanes */
    using bool32x4_t  = simd_type <std::int32_t, 4, simd::boolean_tag>;
    using int32x4_t   = simd_type <std::int32_t, 4>;
    using uint32x4_t  = simd_type <std::uint32_t, 4>;
    using float32x4_t = simd_type <float, 4>;
    using complex_float32x4_t = simd_type <float, 4, simd::complex_tag>;

    /* 2 64-bit lanes */
    using bool64x2_t  = simd_type <std::int64_t, 2, simd::boolean_tag>;
    using int64x2_t   = simd_type <std::int64_t, 2>;
    using uint64x2_t  = simd_type <std::uint64_t, 2>;
    using float64x2_t = simd_type <double, 2>;
    using complex_float64x2_t = simd_type <double, 2, simd::complex_tag>;

    /* 1 128-bit lane (x86 doublequadword) */
#if defined (__clang__)
    using bool128x1_t = simd_type <__int128_t, 1, simd::boolean_tag>;
    using int128x1_t  = simd_type <__int128_t, 1>;
    using uint128x1_t = simd_type <__uint128_t, 1>;
#elif defined (__GNUG__)
    using bool128x1_t = simd_type <__int128, 1, simd::boolean_tag>;
    using int128x1_t  = simd_type <__int128, 1>;
    using uint128x1_t = simd_type <unsigned __int128, 1>;
#endif
}   // namespace ssse3

namespace sse4
{
    /* mmx registers (64-bit) */
    /* 8 8-bit lanes */
    using bool8x8_t = simd_type <std::int8_t, 8, simd::boolean_tag>;
    using int8x8_t  = simd_type <std::int8_t, 8>;
    using uint8x8_t = simd_type <std::uint8_t, 8>;

    /* 4 16-bit lanes */
    using bool16x4_t = simd_type <std::int16_t, 4, simd::boolean_tag>;
    using int16x4_t  = simd_type <std::int16_t, 4>;
    using uint16x4_t = simd_type <std::uint16_t, 4>;

    /* 2 32-bit lanes */
    using bool32x2_t  = simd_type <std::int32_t, 2, simd::boolean_tag>;
    using int32x2_t   = simd_type <std::int32_t, 2>;
    using uint32x2_t  = simd_type <std::uint32_t, 2>;

    /* 1 64-bit lane */
    using bool64x1_t  = simd_type <std::int64_t, 1, simd::boolean_tag>;
    using int64x1_t   = simd_type <std::int64_t, 1>;
    using uint64x1_t  = simd_type <std::uint64_t, 1>;

    /* xmm registers (128-bit) */
    /* 16 8-bit lanes */
    using bool8x16_t = simd_type <std::int8_t, 16, simd::boolean_tag>;
    using int8x16_t  = simd_type <std::int8_t, 16>;
    using uint8x16_t = simd_type <std::uint8_t, 16>;

    /* 8 16-bit lanes */
    using bool16x8_t = simd_type <std::int16_t, 8, simd::boolean_tag>;
    using int16x8_t  = simd_type <std::int16_t, 8>;
    using uint16x8_t = simd_type <std::uint16_t, 8>;

    /* 4 32-bit lanes */
    using bool32x4_t  = simd_type <std::int32_t, 4, simd::boolean_tag>;
    using int32x4_t   = simd_type <std::int32_t, 4>;
    using uint32x4_t  = simd_type <std::uint32_t, 4>;
    using float32x4_t = simd_type <float, 4>;
    using complex_float32x4_t = simd_type <float, 4, simd::complex_tag>;

    /* 2 64-bit lanes */
    using bool64x2_t  = simd_type <std::int64_t, 2, simd::boolean_tag>;
    using int64x2_t   = simd_type <std::int64_t, 2>;
    using uint64x2_t  = simd_type <std::uint64_t, 2>;
    using float64x2_t = simd_type <double, 2>;
    using complex_float64x2_t = simd_type <double, 2, simd::complex_tag>;

    /* 1 128-bit lane (x86 doublequadword) */
#if defined (__clang__)
    using bool128x1_t = simd_type <__int128_t, 1, simd::boolean_tag>;
    using int128x1_t  = simd_type <__int128_t, 1>;
    using uint128x1_t = simd_type <__uint128_t, 1>;
#elif defined (__GNUG__)
    using bool128x1_t = simd_type <__int128, 1, simd::boolean_tag>;
    using int128x1_t  = simd_type <__int128, 1>;
    using uint128x1_t = simd_type <unsigned __int128, 1>;
#endif
}   // namespace sse4

namespace sse4_1 = sse4;
namespace sse4_2 = sse4;

namespace sse4a
{
    /* mmx registers (64-bit) */
    /* 8 8-bit lanes */
    using bool8x8_t = simd_type <std::int8_t, 8, simd::boolean_tag>;
    using int8x8_t  = simd_type <std::int8_t, 8>;
    using uint8x8_t = simd_type <std::uint8_t, 8>;

    /* 4 16-bit lanes */
    using bool16x4_t = simd_type <std::int16_t, 4, simd::boolean_tag>;
    using int16x4_t  = simd_type <std::int16_t, 4>;
    using uint16x4_t = simd_type <std::uint16_t, 4>;

    /* 2 32-bit lanes */
    using bool32x2_t  = simd_type <std::int32_t, 2, simd::boolean_tag>;
    using int32x2_t   = simd_type <std::int32_t, 2>;
    using uint32x2_t  = simd_type <std::uint32_t, 2>;

    /* 1 64-bit lane */
    using bool64x1_t  = simd_type <std::int64_t, 1, simd::boolean_tag>;
    using int64x1_t   = simd_type <std::int64_t, 1>;
    using uint64x1_t  = simd_type <std::uint64_t, 1>;

    /* xmm registers (128-bit) */
    /* 16 8-bit lanes */
    using bool8x16_t = simd_type <std::int8_t, 16, simd::boolean_tag>;
    using int8x16_t  = simd_type <std::int8_t, 16>;
    using uint8x16_t = simd_type <std::uint8_t, 16>;

    /* 8 16-bit lanes */
    using bool16x8_t = simd_type <std::int16_t, 8, simd::boolean_tag>;
    using int16x8_t  = simd_type <std::int16_t, 8>;
    using uint16x8_t = simd_type <std::uint16_t, 8>;

    /* 4 32-bit lanes */
    using bool32x4_t  = simd_type <std::int32_t, 4, simd::boolean_tag>;
    using int32x4_t   = simd_type <std::int32_t, 4>;
    using uint32x4_t  = simd_type <std::uint32_t, 4>;
    using float32x4_t = simd_type <float, 4>;
    using complex_float32x4_t = simd_type <float, 4, simd::complex_tag>;

    /* 2 64-bit lanes */
    using bool64x2_t  = simd_type <std::int64_t, 2, simd::boolean_tag>;
    using int64x2_t   = simd_type <std::int64_t, 2>;
    using uint64x2_t  = simd_type <std::uint64_t, 2>;
    using float64x2_t = simd_type <double, 2>;
    using complex_float64x2_t = simd_type <double, 2, simd::complex_tag>;

    /* 1 128-bit lane (x86 doublequadword) */
#if defined (__clang__)
    using bool128x1_t = simd_type <__int128_t, 1, simd::boolean_tag>;
    using int128x1_t  = simd_type <__int128_t, 1>;
    using uint128x1_t = simd_type <__uint128_t, 1>;
#elif defined (__GNUG__)
    using bool128x1_t = simd_type <__int128, 1, simd::boolean_tag>;
    using int128x1_t  = simd_type <__int128, 1>;
    using uint128x1_t = simd_type <unsigned __int128, 1>;
#endif
}   // namespace sse4a

namespace avx
{
    /* mmx registers (64-bit) */
    /* 8 8-bit lanes */
    using bool8x8_t = simd_type <std::int8_t, 8, simd::boolean_tag>;
    using int8x8_t  = simd_type <std::int8_t, 8>;
    using uint8x8_t = simd_type <std::uint8_t, 8>;

    /* 4 16-bit lanes */
    using bool16x4_t = simd_type <std::int16_t, 4, simd::boolean_tag>;
    using int16x4_t  = simd_type <std::int16_t, 4>;
    using uint16x4_t = simd_type <std::uint16_t, 4>;

    /* 2 32-bit lanes */
    using bool32x2_t  = simd_type <std::int32_t, 2, simd::boolean_tag>;
    using int32x2_t   = simd_type <std::int32_t, 2>;
    using uint32x2_t  = simd_type <std::uint32_t, 2>;

    /* 1 64-bit lane */
    using bool64x1_t  = simd_type <std::int64_t, 1, simd::boolean_tag>;
    using int64x1_t   = simd_type <std::int64_t, 1>;
    using uint64x1_t  = simd_type <std::uint64_t, 1>;

    /* xmm registers (128-bit) */
    /* 16 8-bit lanes */
    using bool8x16_t = simd_type <std::int8_t, 16, simd::boolean_tag>;
    using int8x16_t  = simd_type <std::int8_t, 16>;
    using uint8x16_t = simd_type <std::uint8_t, 16>;

    /* 8 16-bit lanes */
    using bool16x8_t = simd_type <std::int16_t, 8, simd::boolean_tag>;
    using int16x8_t  = simd_type <std::int16_t, 8>;
    using uint16x8_t = simd_type <std::uint16_t, 8>;

    /* 4 32-bit lanes */
    using bool32x4_t  = simd_type <std::int32_t, 4, simd::boolean_tag>;
    using int32x4_t   = simd_type <std::int32_t, 4>;
    using uint32x4_t  = simd_type <std::uint32_t, 4>;
    using float32x4_t = simd_type <float, 4>;
    using complex_float32x4_t = simd_type <float, 4, simd::complex_tag>;

    /* 2 64-bit lanes */
    using bool64x2_t  = simd_type <std::int64_t, 2, simd::boolean_tag>;
    using int64x2_t   = simd_type <std::int64_t, 2>;
    using uint64x2_t  = simd_type <std::uint64_t, 2>;
    using float64x2_t = simd_type <double, 2>;
    using complex_float64x2_t = simd_type <double, 2, simd::complex_tag>;

    /* 1 128-bit lane (x86 doublequadword) */
#if defined (__clang__)
    using bool128x1_t = simd_type <__int128_t, 1, simd::boolean_tag>;
    using int128x1_t  = simd_type <__int128_t, 1>;
    using uint128x1_t = simd_type <__uint128_t, 1>;
#elif defined (__GNUG__)
    using bool128x1_t = simd_type <__int128, 1, simd::boolean_tag>;
    using int128x1_t  = simd_type <__int128, 1>;
    using uint128x1_t = simd_type <unsigned __int128, 1>;
#endif

    /* ymm registers (256-bit) */
    /* 8 32-bit lanes */
    using float32x8_t = simd_type <float, 8>;
    using complex_float32x8_t = simd_type <float, 8, simd::complex_tag>;

    /* 4 64-bit lanes */
    using float64x4_t = simd_type <double, 4>;
    using complex_float64x4_t = simd_type <double, 4, simd::complex_tag>;
}   // namespace avx

namespace avx2
{
    /* mmx registers (64-bit) */
    /* 8 8-bit lanes */
    using bool8x8_t = simd_type <std::int8_t, 8, simd::boolean_tag>;
    using int8x8_t  = simd_type <std::int8_t, 8>;
    using uint8x8_t = simd_type <std::uint8_t, 8>;

    /* 4 16-bit lanes */
    using bool16x4_t = simd_type <std::int16_t, 4, simd::boolean_tag>;
    using int16x4_t  = simd_type <std::int16_t, 4>;
    using uint16x4_t = simd_type <std::uint16_t, 4>;

    /* 2 32-bit lanes */
    using bool32x2_t  = simd_type <std::int32_t, 2, simd::boolean_tag>;
    using int32x2_t   = simd_type <std::int32_t, 2>;
    using uint32x2_t  = simd_type <std::uint32_t, 2>;

    /* 1 64-bit lane */
    using bool64x1_t  = simd_type <std::int64_t, 1, simd::boolean_tag>;
    using int64x1_t   = simd_type <std::int64_t, 1>;
    using uint64x1_t  = simd_type <std::uint64_t, 1>;

    /* xmm registers (128-bit) */
    /* 16 8-bit lanes */
    using bool8x16_t = simd_type <std::int8_t, 16, simd::boolean_tag>;
    using int8x16_t  = simd_type <std::int8_t, 16>;
    using uint8x16_t = simd_type <std::uint8_t, 16>;

    /* 8 16-bit lanes */
    using bool16x8_t = simd_type <std::int16_t, 8, simd::boolean_tag>;
    using int16x8_t  = simd_type <std::int16_t, 8>;
    using uint16x8_t = simd_type <std::uint16_t, 8>;

    /* 4 32-bit lanes */
    using bool32x4_t  = simd_type <std::int32_t, 4, simd::boolean_tag>;
    using int32x4_t   = simd_type <std::int32_t, 4>;
    using uint32x4_t  = simd_type <std::uint32_t, 4>;
    using float32x4_t = simd_type <float, 4>;
    using complex_float32x4_t = simd_type <float, 4, simd::complex_tag>;

    /* 2 64-bit lanes */
    using bool64x2_t  = simd_type <std::int64_t, 2, simd::boolean_tag>;
    using int64x2_t   = simd_type <std::int64_t, 2>;
    using uint64x2_t  = simd_type <std::uint64_t, 2>;
    using float64x2_t = simd_type <double, 2>;
    using complex_float64x2_t = simd_type <double, 2, simd::complex_tag>;

    /* 1 128-bit lane (x86 doublequadword) */
#if defined (__clang__)
    using bool128x1_t = simd_type <__int128_t, 1, simd::boolean_tag>;
    using int128x1_t  = simd_type <__int128_t, 1>;
    using uint128x1_t = simd_type <__uint128_t, 1>;
#elif defined (__GNUG__)
    using bool128x1_t = simd_type <__int128, 1, simd::boolean_tag>;
    using int128x1_t  = simd_type <__int128, 1>;
    using uint128x1_t = simd_type <unsigned __int128, 1>;
#endif

    /* ymm registers (256-bit) */
    /* 8 32-bit lanes */
    using bool32x8_t  = simd_type <std::int32_t, 8, simd::boolean_tag>;
    using int32x8_t   = simd_type <std::int32_t, 8>;
    using uint32x8_t  = simd_type <std::uint32_t, 8>;
    using float32x8_t = simd_type <float, 8>;
    using complex_float32x8_t = simd_type <float, 8, simd::complex_tag>;

    /* 4 64-bit lanes */
    using bool64x4_t  = simd_type <std::int64_t, 4, simd::boolean_tag>;
    using int64x4_t   = simd_type <std::int64_t, 4>;
    using uint64x4_t  = simd_type <std::uint64_t, 4>;
    using float64x4_t = simd_type <double, 4>;
    using complex_float64x4_t = simd_type <double, 4, simd::complex_tag>;
}   // namespace avx2

namespace avx512
{
    /* mmx registers (64-bit) */
    /* 8 8-bit lanes */
    using bool8x8_t = simd_type <std::int8_t, 8, simd::boolean_tag>;
    using int8x8_t  = simd_type <std::int8_t, 8>;
    using uint8x8_t = simd_type <std::uint8_t, 8>;

    /* 4 16-bit lanes */
    using bool16x4_t = simd_type <std::int16_t, 4, simd::boolean_tag>;
    using int16x4_t  = simd_type <std::int16_t, 4>;
    using uint16x4_t = simd_type <std::uint16_t, 4>;

    /* 2 32-bit lanes */
    using bool32x2_t = simd_type <std::int32_t, 2, simd::boolean_tag>;
    using int32x2_t  = simd_type <std::int32_t, 2>;
    using uint32x2_t = simd_type <std::uint32_t, 2>;

    /* 1 64-bit lane */
    using bool64x1_t = simd_type <std::int64_t, 1, simd::boolean_tag>;
    using int64x1_t  = simd_type <std::int64_t, 1>;
    using uint64x1_t = simd_type <std::uint64_t, 1>;

    /* xmm registers (128-bit) */
    /* 16 8-bit lanes */
    using bool8x16_t = simd_type <std::int8_t, 16, simd::boolean_tag>;
    using int8x16_t  = simd_type <std::int8_t, 16>;
    using uint8x16_t = simd_type <std::uint8_t, 16>;

    /* 8 16-bit lanes */
    using bool16x8_t = simd_type <std::int16_t, 8, simd::boolean_tag>;
    using int16x8_t  = simd_type <std::int16_t, 8>;
    using uint16x8_t = simd_type <std::uint16_t, 8>;

    /* 4 32-bit lanes */
    using bool32x4_t  = simd_type <std::int32_t, 4, simd::boolean_tag>;
    using int32x4_t   = simd_type <std::int32_t, 4>;
    using uint32x4_t  = simd_type <std::uint32_t, 4>;
    using float32x4_t = simd_type <float, 4>;
    using complex_float32x4_t = simd_type <float, 4, simd::complex_tag>;

    /* 2 64-bit lanes */
    using bool64x2_t  = simd_type <std::int64_t, 2, simd::boolean_tag>;
    using int64x2_t   = simd_type <std::int64_t, 2>;
    using uint64x2_t  = simd_type <std::uint64_t, 2>;
    using float64x2_t = simd_type <double, 2>;
    using complex_float64x2_t = simd_type <double, 2, simd::complex_tag>;

    /* 1 128-bit lane (x86 doublequadword) */
#if defined (__clang__)
    using bool128x1_t = simd_type <__int128_t, 1, simd::boolean_tag>;
    using int128x1_t  = simd_type <__int128_t, 1>;
    using uint128x1_t = simd_type <__uint128_t, 1>;
#elif defined (__GNUG__)
    using bool128x1_t = simd_type <__int128, 1, simd::boolean_tag>;
    using int128x1_t  = simd_type <__int128, 1>;
    using uint128x1_t = simd_type <unsigned __int128, 1>;
#endif

    /* ymm registers (256-bit) */
    /* 8 32-bit lanes */
    using bool32x8_t  = simd_type <std::int32_t, 8, simd::boolean_tag>;
    using int32x8_t   = simd_type <std::int32_t, 8>;
    using uint32x8_t  = simd_type <std::uint32_t, 8>;
    using float32x8_t = simd_type <float, 8>;
    using complex_float32x8_t = simd_type <float, 8, simd::complex_tag>;

    /* 4 64-bit lanes */
    using bool64x4_t  = simd_type <std::int64_t, 4, simd::boolean_tag>;
    using int64x4_t   = simd_type <std::int64_t, 4>;
    using uint64x4_t  = simd_type <std::uint64_t, 4>;
    using float64x4_t = simd_type <double, 4>;
    using complex_float64x4_t = simd_type <double, 4, simd::complex_tag>;

    /* zmm registers (512-bit) */
    /* 16 32-bit lanes */
    using bool32x16_t  = simd_type <std::int32_t, 16, simd::boolean_tag>;
    using int32x16_t   = simd_type <std::int32_t, 16>;
    using uint32x16_t  = simd_type <std::uint32_t, 16>;
    using float32x16_t = simd_type <float, 16>;
    using complex_float32x16_t = simd_type <float, 16, simd::complex_tag>;

    /* 8 64-bit lanes */
    using bool64x8_t  = simd_type <std::int64_t, 8, simd::boolean_tag>;
    using int64x8_t   = simd_type <std::int64_t, 8>;
    using uint64x8_t  = simd_type <std::uint64_t, 8>;
    using float64x8_t = simd_type <double, 8>;
    using complex_float64x8_t = simd_type <double, 8, simd::complex_tag>;
}   // namespace avx512

namespace neon
{
    /* 64-bit registers (ARM doubleword registers -- D0, D1, ...) */
    /* 8 8-bit lanes */
    using bool8x8_t = simd_type <std::int8_t, 8, simd::boolean_tag>;
    using int8x8_t  = simd_type <std::int8_t, 8>;
    using uint8x8_t = simd_type <std::uint8_t, 8>;

    /* 4 16-bit lanes */
    using bool16x4_t = simd_type <std::int16_t, 4, simd::boolean_tag>;
    using int16x4_t  = simd_type <std::int16_t, 4>;
    using uint16x4_t = simd_type <std::uint16_t, 4>;

    /* 2 32-bit lanes */
    using bool32x2_t  = simd_type <std::int32_t, 2, simd::boolean_tag>;
    using int32x2_t   = simd_type <std::int32_t, 2>;
    using uint32x2_t  = simd_type <std::uint32_t, 2>;
    using float32x2_t = simd_type <float, 2>;

    /* 1 64-bit lane */
    using bool64x1_t  = simd_type <std::int64_t, 1, simd::boolean_tag>;
    using int64x1_t   = simd_type <std::int64_t, 1>;
    using uint64x1_t  = simd_type <std::uint64_t, 1>;

    /* 128-bit registers (ARM quadword registers -- Q0, Q1, ...) */
    /* 16 8-bit lanes */
    using bool8x16_t = simd_type <std::int8_t, 16, simd::boolean_tag>;
    using int8x16_t  = simd_type <std::int8_t, 16>;
    using uint8x16_t = simd_type <std::uint8_t, 16>;

    /* 8 16-bit lanes */
    using bool16x8_t = simd_type <std::int16_t, 8, simd::boolean_tag>;
    using int16x8_t  = simd_type <std::int16_t, 8>;
    using uint16x8_t = simd_type <std::uint16_t, 8>;

    /* 4 32-bit lanes */
    using bool32x4_t  = simd_type <std::int32_t, 4, simd::boolean_tag>;
    using int32x4_t   = simd_type <std::int32_t, 4>;
    using uint32x4_t  = simd_type <std::uint32_t, 4>;
    using float32x4_t = simd_type <float, 4>;
    using complex_float32x4_t = simd_type <float, 4, simd::complex_tag>;

    /* 2 64-bit lane */
    using bool64x2_t  = simd_type <std::int64_t, 2, simd::boolean_tag>;
    using int64x2_t   = simd_type <std::int64_t, 2>;
    using uint64x2_t  = simd_type <std::uint64_t, 2>;
}   // namespace neon
}   // namespace simd

#undef advanced_constexpr
#undef simd_arm
#undef simd_neon
#undef simd_x86
#undef simd_mmx
#undef simd_sse
#undef simd_sse2
#undef simd_sse3
#undef simd_ssse3
#undef simd_see4_1
#undef simd_see4_2
#undef simd_avx
#undef simd_avx2
#undef simd_avx512

#include <cctype>    // std::is[x]digit
#include <cwctype>   // std::isw[x]digit
#include <iostream>  // std::(w){i,o}stream

/*
 * The following provide overloads for std namespace functions, including:
 *      - operator<< (narrow and wide character streams)
 *      - operator>> (narrow and wide character streams)
 *      - std::hash
 */

template <
    typename SimdT,
    typename = typename std::enable_if <
        simd::detail::is_simd_type <SimdT>::value
    >::type
>
std::ostream & operator<< (std::ostream & os, SimdT const & v)
{
    static constexpr std::size_t lanes = simd::simd_traits <SimdT>::lanes;

    std::ostream::sentry s {os};
    if (s) {
        os << '(';
        for (std::size_t i = 0; i < lanes - 1; ++i) {
            os << v [i] << "; ";
        }
        os << v [lanes - 1] << ')';
    }

    return os;
}

template <
    typename SimdT,
    typename = typename std::enable_if <
        simd::detail::is_simd_type <SimdT>::value
    >::type
>
std::wostream & operator<< (std::wostream & os, SimdT const & v)
{
    static constexpr std::size_t lanes = simd::simd_traits <SimdT>::lanes;

    std::wostream::sentry s {os};
    if (s) {
        os << L'(';
        for (std::size_t i = 0; i < lanes - 1; ++i) {
            os << v [i] << L';' << L' ';
        }
        os << v [lanes - 1] << L')';
    }

    return os;
}

template <
    typename SimdT,
    typename = typename std::enable_if <
        simd::detail::is_simd_type <SimdT>::value
    >::type
>
std::istream & operator>> (std::istream & is, SimdT & v)
{
    using traits = simd::simd_traits <SimdT>;
    using value_type = typename traits::value_type;
    static constexpr std::size_t lanes = traits::lanes;

    auto nonnum = [](std::istream & _is) -> std::istream &
    {
        while (!_is.eof () && !_is.bad ()) {
            auto const flags = _is.flags ();
            auto const peek = _is.peek ();
            if (flags & std::ios_base::dec) {
                if (!std::isdigit (peek)) {
                    _is.ignore ();
                    continue;
                } else {
                    break;
                }
            } else if (flags & std::ios_base::oct) {
                if (!std::isdigit (peek) || peek == '8' || peek == '9') {
                    _is.ignore ();
                    continue;
                } else {
                    break;
                }
            } else if (flags & std::ios_base::hex) {
                if (!std::isxdigit (peek)) {
                    _is.ignore ();
                    continue;
                } else {
                    break;
                }
            }
        }

        return _is;
    };

    {
        std::size_t i = 0;
        while (i < lanes && !is.eof () && !is.bad ()) {
            is >> v [i];
            if (is.fail ()) {
                is.clear ();
                is >> nonnum;
            } else {
                i += 1;
            }
        }

        for (; i < lanes; ++i) {
            v [i] = value_type {0};
        }
    }

    return is;
}

template <
    typename SimdT,
    typename = typename std::enable_if <
        simd::detail::is_simd_type <SimdT>::value
    >::type
>
std::wistream & operator>> (std::wistream & wis, SimdT & v)
{
    using traits = simd::simd_traits <SimdT>;
    using value_type = typename traits::value_type;
    static constexpr std::size_t lanes = traits::lanes;

    auto nonnum = [](std::wistream & _wis) -> std::wistream &
    {
        while (!_wis.eof () && !_wis.bad ()) {
            auto const flags = _wis.flags ();
            auto const peek = _wis.peek ();
            if (flags & std::ios_base::dec) {
                if (!std::iswdigit (peek)) {
                    _wis.ignore ();
                    continue;
                } else {
                    break;
                }
            } else if (flags & std::ios_base::oct) {
                if (!std::iswdigit (peek) || peek == L'8' || peek == L'9') {
                    _wis.ignore ();
                    continue;
                } else {
                    break;
                }
            } else if (flags & std::ios_base::hex) {
                if (!std::iswxdigit (peek)) {
                    _wis.ignore ();
                    continue;
                } else {
                    break;
                }
            }
        }

        return _wis;
    };

    {
        std::size_t i = 0;
        while (i < lanes && !wis.eof () && !wis.bad ()) {
            wis >> v [i];
            if (wis.fail ()) {
                wis.clear ();
                wis >> nonnum;
            } else {
                i += 1;
            }
        }

        for (; i < lanes; ++i) {
            v [i] = value_type {0};
        }
    }

    return wis;
}

namespace std
{
    /*
     * Computes a single hash value for an object of a SIMD vector type.
     */
#define std_hash_impl(ty, lanes, tag) template <>\
    struct hash <simd::simd_type <ty, lanes, tag>>\
    {\
        typedef simd::simd_type <ty, lanes, tag> argument_type;\
        typedef std::size_t result_type;\
\
        result_type operator() (argument_type const & s) const noexcept\
        {\
            using value_type = typename simd::simd_traits <\
                argument_type\
            >::value_type;\
\
            return simd::accumulate (\
                simd::hash <argument_type> (s), std::size_t {0},\
                [] (std::size_t const & seed, value_type const & t) {\
                    return simd::detail::util::hash_combine <value_type> (\
                            seed, t\
                    );\
                }\
            );\
        }\
    };

#define std_hash_impl_lanes(ty)\
    std_hash_impl(ty, 1, simd::boolean_tag)\
    std_hash_impl(ty, 2, simd::boolean_tag)\
    std_hash_impl(ty, 4, simd::boolean_tag)\
    std_hash_impl(ty, 8, simd::boolean_tag)\
    std_hash_impl(ty, 16, simd::boolean_tag)\
    std_hash_impl(ty, 32, simd::boolean_tag)\
    std_hash_impl(ty, 64, simd::boolean_tag)\
    std_hash_impl(ty, 1, simd::arithmetic_tag)\
    std_hash_impl(ty, 2, simd::arithmetic_tag)\
    std_hash_impl(ty, 4, simd::arithmetic_tag)\
    std_hash_impl(ty, 8, simd::arithmetic_tag)\
    std_hash_impl(ty, 16, simd::arithmetic_tag)\
    std_hash_impl(ty, 32, simd::arithmetic_tag)\
    std_hash_impl(ty, 64, simd::arithmetic_tag)\
    std_hash_impl(unsigned ty, 1, simd::arithmetic_tag)\
    std_hash_impl(unsigned ty, 2, simd::arithmetic_tag)\
    std_hash_impl(unsigned ty, 4, simd::arithmetic_tag)\
    std_hash_impl(unsigned ty, 8, simd::arithmetic_tag)\
    std_hash_impl(unsigned ty, 16, simd::arithmetic_tag)\
    std_hash_impl(unsigned ty, 32, simd::arithmetic_tag)\
    std_hash_impl(unsigned ty, 64, simd::arithmetic_tag)

    std_hash_impl_lanes(char)
    std_hash_impl_lanes(short)
    std_hash_impl_lanes(int)
    std_hash_impl_lanes(long)
    std_hash_impl_lanes(long long)

#undef std_hash_impl_lanes

#define std_hash_impl_float_lanes(ty)\
    std_hash_impl(ty, 1, simd::arithmetic_tag)\
    std_hash_impl(ty, 2, simd::arithmetic_tag)\
    std_hash_impl(ty, 4, simd::arithmetic_tag)\
    std_hash_impl(ty, 8, simd::arithmetic_tag)\
    std_hash_impl(ty, 16, simd::arithmetic_tag)\
    std_hash_impl(ty, 32, simd::arithmetic_tag)\
    std_hash_impl(ty, 64, simd::arithmetic_tag)

    std_hash_impl_float_lanes(float)
    std_hash_impl_float_lanes(double)
    std_hash_impl_float_lanes(long double)

#undef std_hash_impl_float_lanes
#undef std_hash_impl

#define std_hash_impl_int128(ty, lanes, tag) template <>\
    struct hash <simd::simd_type <ty, lanes, tag>>\
    {\
        typedef simd::simd_type <ty, lanes, tag> argument_type;\
        typedef std::size_t result_type;\
\
        result_type operator() (argument_type const & s) const noexcept\
        {\
            struct alias {\
                simd::simd_type <std::uint64_t, lanes, simd::arithmetic_tag>\
                    v1;\
                simd::simd_type <std::uint64_t, lanes, simd::arithmetic_tag>\
                    v2;\
            };\
\
            auto const & a = reinterpret_cast <alias const &> (s);\
            auto h1 = simd::hash <decltype (a.v1)> (a.v1);\
            auto h2 = simd::hash <decltype (a.v2)> (a.v2);\
\
            using hash_type = decltype (h1);\
            using hash_value_type =\
                typename simd::simd_traits <hash_type>::value_type;\
            return simd::accumulate (\
                h1 ^ ((h2  + hash_type {hash_value_type {0x9e3779b9}}) +\
                      (h1 << hash_type {hash_value_type {6}}) +\
                      (h1 >> hash_type {hash_value_type {2}})),\
                std::size_t {0},\
                [] (std::size_t const & seed, std::uint64_t const & t) {\
                    return simd::detail::util::hash_combine <std::uint64_t> (\
                            seed, t\
                    );\
                }\
            );\
        }\
    };

#if defined (__clang__)
    std_hash_impl_int128(__int128_t, 1, simd::boolean_tag)
    std_hash_impl_int128(__int128_t, 2, simd::boolean_tag)
    std_hash_impl_int128(__int128_t, 4, simd::boolean_tag)
    std_hash_impl_int128(__int128_t, 8, simd::boolean_tag)
    std_hash_impl_int128(__int128_t, 16, simd::boolean_tag)
    std_hash_impl_int128(__int128_t, 32, simd::boolean_tag)
    std_hash_impl_int128(__int128_t, 64, simd::boolean_tag)
    std_hash_impl_int128(__int128_t, 1, simd::arithmetic_tag)
    std_hash_impl_int128(__int128_t, 2, simd::arithmetic_tag)
    std_hash_impl_int128(__int128_t, 4, simd::arithmetic_tag)
    std_hash_impl_int128(__int128_t, 8, simd::arithmetic_tag)
    std_hash_impl_int128(__int128_t, 16, simd::arithmetic_tag)
    std_hash_impl_int128(__int128_t, 32, simd::arithmetic_tag)
    std_hash_impl_int128(__int128_t, 64, simd::arithmetic_tag)
    std_hash_impl_int128(__uint128_t, 1, simd::arithmetic_tag)
    std_hash_impl_int128(__uint128_t, 2, simd::arithmetic_tag)
    std_hash_impl_int128(__uint128_t, 4, simd::arithmetic_tag)
    std_hash_impl_int128(__uint128_t, 8, simd::arithmetic_tag)
    std_hash_impl_int128(__uint128_t, 16, simd::arithmetic_tag)
    std_hash_impl_int128(__uint128_t, 32, simd::arithmetic_tag)
    std_hash_impl_int128(__uint128_t, 64, simd::arithmetic_tag)
#elif defined (__GNUG__)
    std_hash_impl_int128(__int128, 1, simd::boolean_tag)
    std_hash_impl_int128(__int128, 2, simd::boolean_tag)
    std_hash_impl_int128(__int128, 4, simd::boolean_tag)
    std_hash_impl_int128(__int128, 8, simd::boolean_tag)
    std_hash_impl_int128(__int128, 16, simd::boolean_tag)
    std_hash_impl_int128(__int128, 32, simd::boolean_tag)
    std_hash_impl_int128(__int128, 64, simd::boolean_tag)
    std_hash_impl_int128(__int128, 1, simd::arithmetic_tag)
    std_hash_impl_int128(__int128, 2, simd::arithmetic_tag)
    std_hash_impl_int128(__int128, 4, simd::arithmetic_tag)
    std_hash_impl_int128(__int128, 8, simd::arithmetic_tag)
    std_hash_impl_int128(__int128, 16, simd::arithmetic_tag)
    std_hash_impl_int128(__int128, 32, simd::arithmetic_tag)
    std_hash_impl_int128(__int128, 64, simd::arithmetic_tag)
    std_hash_impl_int128(unsigned __int128, 1, simd::arithmetic_tag)
    std_hash_impl_int128(unsigned __int128, 2, simd::arithmetic_tag)
    std_hash_impl_int128(unsigned __int128, 4, simd::arithmetic_tag)
    std_hash_impl_int128(unsigned __int128, 8, simd::arithmetic_tag)
    std_hash_impl_int128(unsigned __int128, 16, simd::arithmetic_tag)
    std_hash_impl_int128(unsigned __int128, 32, simd::arithmetic_tag)
    std_hash_impl_int128(unsigned __int128, 64, simd::arithmetic_tag)
#endif

#undef std_hash_impl_int128
}   // namespace std

#endif  // #ifndef SIMD_IMPLEMENTATION_HEADER
